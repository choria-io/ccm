<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Choria Configuration Manager</title><link>https://choria-cm.dev/index.html</link><description>Overview Mainstream Configuration Management systems focus on full-system management, optimized for hundreds or thousands of managed resources per node. This makes them complex and dependency-heavy.
Traditional Configuration Management tools are not well suited for application management—they focus on systems management. They also struggle with ad hoc systems where each node is a unique snowflake.
CCM is a small-scale Configuration Management system designed to meet users where they are:</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://choria-cm.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Resources</title><link>https://choria-cm.dev/resources/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://choria-cm.dev/resources/index.html</guid><description>Resources describe the desired state of your infrastructure. Each resource represents something to manage and is backed by a provider that implements platform-specific management logic.
Every resource has a type, a unique name, and resource-specific properties.
Common Properties All resources support the following common properties:
Property Description name Unique identifier for the resource ensure Desired state (values vary by resource type) alias Alternative name for use in subscribe, require, and logging provider Force a specific provider require List of resources (type#name or type#alias) that must succeed first health_checks Health checks to run after applying (see Monitoring) control Conditional execution rules (see below) Conditional Resource Execution Resources can be conditionally executed using a control section and expressions that should resolve to boolean values.</description></item><item><title>Hierarchical Data</title><link>https://choria-cm.dev/hiera/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://choria-cm.dev/hiera/index.html</guid><description>The Choria Hierarchical Data Resolver is a small data resolver inspired by Hiera. It evaluates a YAML or JSON document alongside a set of facts to produce a final data map.
The resolver supports first and deep merge strategies and relies on expression-based string interpolation for hierarchy entries. It is optimized for single files that hold both hierarchy and data, rather than the multi-file approach common in Hiera.
Key features:</description></item><item><title>Data</title><link>https://choria-cm.dev/data/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://choria-cm.dev/data/index.html</guid><description>Just like applications need data to vary their behavior and configure their environments, so do Configuration Management tools.
For this reason, I wrote extlookup and hiera years ago for the Puppet community. Despite CCM’s minimal focus, we still need data to vary behavior.
Data can be used for:
Configuring resource names that differ between operating systems (e.g., httpd vs apache2) Setting different configuration values depending on environment, role, or other dimensions Deciding whether environments should have something installed (e.g., development vs production) CCM supports various data sources:</description></item><item><title>Shell Usage</title><link>https://choria-cm.dev/cli/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://choria-cm.dev/cli/index.html</guid><description>CCM is designed as a CLI-first tool. Each resource type has its own subcommand under ccm ensure, with required inputs as arguments and optional settings as flags.
The ccm ensure commands are idempotent, making them safe to run multiple times in shell scripts.
Use ccm --help and ccm &lt;command&gt; --help to explore available commands and options.
Managing a Single Resource Managing a single resource is straightforward.</description></item><item><title>YAML Manifests</title><link>https://choria-cm.dev/yamlmanifests/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://choria-cm.dev/yamlmanifests/index.html</guid><description>A manifest is a YAML file that combines data, hierarchy configuration, and resources in a single file.
Manifests support template expressions but not procedural logic. Think of them as declarative configuration similar to multi-resource shell scripts.
Note A JSON Schema for manifests is available at https://choria.io/schemas/ccm/v1/manifest.json. Configure your editor to use this schema for completion and validation.
Manifest Structure A manifest contains these top-level sections:</description></item><item><title>Agent</title><link>https://choria-cm.dev/agent/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://choria-cm.dev/agent/index.html</guid><description>For certain use cases, it is useful to run YAML Manifests continuously. For example, you might not want to manage your dotfiles automatically (allowing for local modifications), but you do want to keep Docker up to date.
The CCM Agent runs manifests continuously, loading them from local files, Object Storage, or HTTP(S) URLs, with Key-Value data overlaid.
In time, the Agent will become a key part of a service registry system, allowing for continuous monitoring of managed resources and sharing that state into a registry—enabling other nodes to use file resources to create configurations that combine knowledge of all nodes.</description></item><item><title>Monitoring</title><link>https://choria-cm.dev/monitoring/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://choria-cm.dev/monitoring/index.html</guid><description>By default, CCM verifies resource health using the resource’s native state. For example, if a service should be running and systemd reports it as running, CCM considers it healthy.
For deeper validation, all resources support custom health checks. These checks run after a resource is managed and can verify that the resource is functioning correctly, not just present.
Health Check Properties Property Description Default command Command to execute (required) - name Name for logging and metrics Command base name tries Number of attempts before failing 1 try_sleep Duration to wait between retry attempts 1s timeout Maximum time for command execution No timeout format Output format interpretation nagios Nagios Format Health checks use Nagios plugin conventions for exit codes:</description></item></channel></rss>