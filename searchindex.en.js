var relearn_searchindex = [
  {
    "breadcrumb": "Choria Configuration Manager \u003e Shell Usage",
    "content": "CCM supports extending the CLI with custom commands using App Builder. This allows you to create organization-specific workflows that integrate with the ccm command.\nPlugin Locations CCM searches for plugins in two directories:\nLocation Purpose /etc/choria/ccm/plugins/ System-wide plugins $XDG_CONFIG_HOME/choria/ccm/plugins/ User plugins (typically ~/.config/choria/ccm/plugins/) Plugins in the user directory override system plugins with the same name.\nPlugin File Format Plugin files must be named \u003ccommand\u003e-plugin.yaml. The filename determines the command name:\ndeploy-plugin.yaml → ccm deploy backup-plugin.yaml → ccm backup myapp-plugin.yaml → ccm myapp Basic Plugin Structure Plugins use App Builder’s YAML definition format. Here’s a minimal example:\n# deploy-plugin.yaml name: deploy description: Deploy application configuration commands: - name: web description: Deploy web server configuration type: exec command: | ccm apply /etc/ccm/manifests/webserver.yaml This creates ccm deploy web which applies a manifest.\nPassing Data to Manifests Plugins can pass data to manifests through environment variables or facts. Both are accessible in manifest templates.\nUsing Environment Variables Environment variables set in the plugin are available in manifests via {{ lookup(\"env.VAR_NAME\") }}:\n# deploy-plugin.yaml name: deploy description: Deploy with environment commands: - name: production description: Deploy to production type: exec environment: - \"DEPLOY_ENV=production\" - \"LOG_LEVEL=warn\" command: | ccm apply /etc/ccm/manifests/app.yaml In the manifest:\nresources: - type: file name: /etc/app/config.yaml content: | environment: {{ lookup(\"env.DEPLOY_ENV\") }} log_level: {{ lookup(\"env.LOG_LEVEL\") }} Using Facts Pass additional facts using the --fact flag. Facts are available via {{ lookup(\"facts.KEY\") }}:\n# deploy-plugin.yaml name: deploy description: Deploy with custom facts commands: - name: app description: Deploy application type: exec arguments: - name: version description: Application version to deploy required: true command: | ccm apply /etc/ccm/manifests/app.yaml --fact app_version={{ .Arguments.version }} In the manifest:\nresources: - type: package name: myapp ensure: present version: \"{{ lookup('facts.app_version') }}\" Further Reading For complete App Builder documentation including all command types, templating features, and advanced options, see the App Builder documentation.\nSince version 0.13.0 of App Builder it has a transform and a command that can invoke CCM Manifests, this combines well with flags, arguments and form wizards to create custom UI’s that manage your infrastructure.",
    "description": "CCM supports extending the CLI with custom commands using App Builder. This allows you to create organization-specific workflows that integrate with the ccm command.\nPlugin Locations CCM searches for plugins in two directories:\nLocation Purpose /etc/choria/ccm/plugins/ System-wide plugins $XDG_CONFIG_HOME/choria/ccm/plugins/ User plugins (typically ~/.config/choria/ccm/plugins/) Plugins in the user directory override system plugins with the same name.\nPlugin File Format Plugin files must be named \u003ccommand\u003e-plugin.yaml. The filename determines the command name:",
    "tags": [],
    "title": "CLI Plugins",
    "uri": "/cli/plugins/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "Resources describe the desired state of your infrastructure. Each resource represents something to manage and is backed by a provider that implements platform-specific management logic.\nEvery resource has a type, a unique name, and resource-specific properties.\nCommon Properties All resources support the following common properties:\nProperty Description name Unique identifier for the resource ensure Desired state (values vary by resource type) alias Alternative name for use in subscribe, require, and logging provider Force a specific provider require List of resources (type#name or type#alias) that must succeed first health_checks Health checks to run after applying (see Monitoring) control Conditional execution rules (see below) Conditional Resource Execution Resources can be conditionally executed using a control section and expressions that should resolve to boolean values.\npackage: name: zsh ensure: 5.9 control: if: lookup(\"facts.host.info.os\") == \"linux\" unless: lookup(\"facts.host.info.virtualizationSystem\") == \"docker\" Here we install zsh on all linux machines unless they are running inside a docker container.\nThe following table shows how the two conditions interact:\nif unless Resource Managed? (not set) (not set) Yes true (not set) Yes false (not set) No (not set) true No (not set) false Yes true true No true false Yes false true No false false No About Names Resources can be specified like:\n/etc/motd: ensure: present This sets name to /etc/motd, in the following paragraphs we will refer to this as name.\nExec The exec resource executes commands to bring the system into the desired state. It is idempotent when used with the creates property or refreshonly mode.\nWarning Specify commands with their full path, or use the path property to set the search path.\nIn a manifest:\n- exec: - /usr/bin/touch /tmp/hello: creates: /tmp/hello timeout: 30s cwd: /tmp Alternatively for long commands or to improve UX for referencing execs in require or subscribe:\n- exec: - touch_hello: command: /usr/bin/touch /tmp/hello creates: /tmp/hello timeout: 30s cwd: /tmp On the CLI:\n$ ccm ensure exec \"/usr/bin/touch /tmp/hello\" --creates /tmp/hello --timeout 30s The command runs only if /tmp/hello does not exist.\nProperties Property Description name The command to execute (used as the resource identifier) command Alternative command to run instead of name cwd Working directory for command execution environment (array) Environment variables in KEY=VALUE format path Search path for executables as a colon-separated list (e.g., /usr/bin:/bin) returns (array) Exit codes indicating success (default: [0]) timeout Maximum execution time (e.g., 30s, 5m); command is killed if exceeded creates File path; if this file exists, the command does not run refreshonly (boolean) Only run when notified by a subscribed resource subscribe (array) Resources to subscribe to for refresh notifications (type#name or type#alias) logoutput (boolean) Log the command output provider Force a specific provider (posix only) File The file resource manages files and directories, including their content, ownership, and permissions.\nWarning Use absolute file paths and primary group names.\nIn a manifest:\n- file: - /etc/motd: ensure: present content: | Managed by CCM {{ now() }} owner: root group: root mode: \"0644\" On the CLI:\n$ ccm ensure file /etc/motd --source /tmp/ccm/motd --owner root --group root --mode 0644 This copies the contents of /tmp/ccm/motd to /etc/motd verbatim and sets ownership.\nUse --content or --content-file to parse content through the template engine before writing.\nEnsure Values Value Description present The file must exist absent The file must not exist directory The path must be a directory Properties Property Description name Absolute path to the file ensure Desired state (present, absent, directory) content File contents, parsed through the template engine source Copy contents from another local file owner File owner (username) group File group (group name) mode File permissions in octal notation (e.g., \"0644\") provider Force a specific provider (posix only) Package The package resource manages system packages. Specify whether the package should be present, absent, at the latest version, or at a specific version.\nWarning Use real package names, not virtual names, aliases, or group names.\nIn a manifest:\n- package: - zsh: ensure: \"5.9\" On the CLI:\n$ ccm ensure package zsh 5.9 Ensure Values Value Description present The package must be installed latest The package must be installed at latest version absent The package must not be installed \u003cversion\u003e The package must be installed at this version Properties Property Description name Package name ensure Desired state or version provider Force a specific provider (dnf only) Service The service resource manages system services. Services have two independent properties: whether they are running and whether they are enabled to start at boot.\nWarning Use real service names, not virtual names or aliases.\nServices can subscribe to other resources and restart when those resources change.\nIn a manifest:\n- service: - httpd: ensure: running enable: true subscribe: - package#httpd On the CLI:\n$ ccm ensure service httpd running --enable --subscribe package#httpd Ensure Values Value Description running The service must be running stopped The service must be stopped If ensure is not specified, it defaults to running.\nProperties Property Description name Service name ensure Desired state (running or stopped; default: running) enable (boolean) Enable the service to start at boot subscribe (array) Resources to watch; restart the service when they change (type#name or type#alias) provider Force a specific provider (systemd only)",
    "description": "Resources describe the desired state of your infrastructure. Each resource represents something to manage and is backed by a provider that implements platform-specific management logic.\nEvery resource has a type, a unique name, and resource-specific properties.\nCommon Properties All resources support the following common properties:\nProperty Description name Unique identifier for the resource ensure Desired state (values vary by resource type) alias Alternative name for use in subscribe, require, and logging provider Force a specific provider require List of resources (type#name or type#alias) that must succeed first health_checks Health checks to run after applying (see Monitoring) control Conditional execution rules (see below) Conditional Resource Execution Resources can be conditionally executed using a control section and expressions that should resolve to boolean values.",
    "tags": [],
    "title": "Resources",
    "uri": "/resources/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "The Choria Hierarchical Data Resolver is a small data resolver inspired by Hiera. It evaluates a YAML or JSON document alongside a set of facts to produce a final data map.\nThe resolver supports first and deep merge strategies and relies on expression-based string interpolation for hierarchy entries. It is optimized for single files that hold both hierarchy and data, rather than the multi-file approach common in Hiera.\nKey features:\nLookup expressions based on the Expr Language Type-preserving lookups (returns typed data, not just strings) Command-line tool with built-in system facts Go library for embedding Usage Here’s an annotated example:\nhierarchy: # Lookup and override order - facts are resolved in expressions # Use GJSON path syntax for nested facts: {{ lookup('facts.host.info.hostname') }} order: - env:{{ lookup('facts.env') }} - role:{{ lookup('facts.role') }} - host:{{ lookup('facts.hostname') }} merge: deep # \"deep\" merges all matches; \"first\" stops at first match # Base data - hierarchy results are merged into this data: log_level: INFO packages: - ca-certificates web: listen_port: 80 tls: false # Override sections keyed by hierarchy order entries overrides: env:prod: log_level: WARN role:web: packages: - nginx web: listen_port: 443 tls: true host:web01: log_level: TRACE The templating here is identical to that in the Data documentation, except only the lookup() function is available (no file access functions).\nDefault Hierarchy If no hierarchy section is provided, the resolver uses a default hierarchy of [\"default\"].\nCLI Example The ccm hiera command resolves hierarchy files with facts. It is designed to be a generally usable tool, with flexible options for providing facts.\nGiven the input file data.json:\n{ \"hierarchy\": { \"order\": [ \"fqdn:{{ lookup('facts.fqdn') }}\" ] }, \"data\": { \"test\": \"value\" }, \"overrides\": { \"fqdn:my.fqdn.com\": { \"test\": \"override\" } } } Resolve with facts provided on the command line:\n$ ccm hiera parse data.json fqdn=my.fqdn.com { \"test\": \"override\" } $ ccm hiera parse data.json fqdn=other.fqdn.com { \"test\": \"value\" } Output formats:\n# YAML output $ ccm hiera parse data.json fqdn=other.fqdn.com --yaml test: value # Environment variable output $ ccm hiera parse data.json fqdn=other.fqdn.com --env HIERA_TEST=value Fact Sources Facts can come from multiple sources, which are merged together:\nSystem facts (-S or --system-facts):\n# View system facts $ ccm hiera facts -S # Resolve using system facts $ ccm hiera parse data.json -S Environment variables as facts (-E or --env-facts):\n$ ccm hiera parse data.json -E Facts file (--facts FILE):\n$ ccm hiera parse data.json --facts facts.yaml Command-line facts (key=value pairs):\n$ ccm hiera parse data.json env=prod role=web All fact sources can be combined. Command-line facts take highest precedence.\nData in NATS NATS is a lightweight messaging system that supports Key-Value stores. Hierarchy data can be stored in NATS and used with ccm ensure and ccm hiera commands.\nTo use NATS as a hierarchy store, configure a NATS context for authentication:\n$ nats context add ccm --server nats.example.org --user ccm --password s3cret --description \"CCM Configuration Store\" Create a KV store and add your hierarchy data:\n$ nats kv add CCM --replicas 3 --context ccm $ nats kv put CCM data \"$(cat hiera.yaml)\" Resolve the hierarchy using the KV store:\n$ ccm hiera parse kv://CCM/data --context ccm -S Data on Web Servers Hierarchy data can also be stored on a web server and fetched via HTTP or HTTPS.\n$ ccm hiera parse https://example.net/site.yaml -S HTTP Basic Auth is supported via URL credentials:\n$ ccm hiera parse https://user:pass@example.net/site.yaml -S Go Example The hiera package can be embedded in Go applications. Supply a YAML document and a map of facts; the resolver parses the hierarchy, replaces {{ lookup('facts.key') }} placeholders, and merges matching sections.\npackage main import ( \"encoding/json\" \"fmt\" \"log/slog\" \"os\" \"github.com/choria-io/ccm/hiera\" \"github.com/choria-io/ccm/manager\" ) func main() { yamlDoc := []byte(` hierarchy: order: - env:{{ lookup('facts.env') }} - role:{{ lookup('facts.role') }} - host:{{ lookup('facts.hostname') }} merge: deep data: log_level: INFO packages: - ca-certificates web: listen_port: 80 tls: false overrides: env:prod: log_level: WARN role:web: packages: - nginx web: tls: true host:web01: log_level: TRACE `) facts := map[string]any{ \"env\": \"prod\", \"role\": \"web\", \"hostname\": \"web01\", } logger := manager.NewSlogLogger( slog.New(slog.NewTextHandler(os.Stderr, \u0026slog.HandlerOptions{Level: slog.LevelInfo}))) resolved, err := hiera.ResolveYaml(yamlDoc, facts, hiera.DefaultOptions, logger) if err != nil { panic(err) } jout, err := json.MarshalIndent(resolved, \"\", \" \") if err != nil { panic(err) } fmt.Println(string(jout)) }",
    "description": "The Choria Hierarchical Data Resolver is a small data resolver inspired by Hiera. It evaluates a YAML or JSON document alongside a set of facts to produce a final data map.\nThe resolver supports first and deep merge strategies and relies on expression-based string interpolation for hierarchy entries. It is optimized for single files that hold both hierarchy and data, rather than the multi-file approach common in Hiera.\nKey features:",
    "tags": [],
    "title": "Hierarchical Data",
    "uri": "/hiera/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "Just like applications need data to vary their behavior and configure their environments, so do Configuration Management tools.\nFor this reason, I wrote extlookup and hiera years ago for the Puppet community. Despite CCM’s minimal focus, we still need data to vary behavior.\nData can be used for:\nConfiguring resource names that differ between operating systems (e.g., httpd vs apache2) Setting different configuration values depending on environment, role, or other dimensions Deciding whether environments should have something installed (e.g., development vs production) CCM supports various data sources:\nSystem Facts - Operating system, networking, and disk configuration Custom Facts - From /etc/choria/ccm/facts.{yaml,json} and ~/.config/choria/ccm/facts.{yaml,json} Environment - Variables from the shell environment and ./.env files Hiera Data - Hierarchical data with overrides based on facts Accessing Data Expressions like {{ lookup('facts.host.info.platformFamily') }} use the Expr Language.\nAvailable Variables In templates, you have direct access to:\nVariable Description Facts System facts (e.g., Facts.host.info.platformFamily) Data Resolved Hiera data (e.g., Data.package_name) Environ Environment variables (e.g., Environ.HOME) Available Functions Function Description lookup(key, default) Lookup data using GJSON Path Syntax. Example: lookup(\"facts.host.info.os\", \"linux\") readFile(path), file(path) Read a file into a string (files must be in the working directory) template(f) Parse f using templates. If f ends in .templ, reads the file first jet(f), jet(f, \"[[\", \"]]\") Parse f using Jet templates with optional custom delimiters. If f ends in .jet, reads the file first GJSON Path Examples The lookup() function uses GJSON path syntax for nested access:\nlookup(\"facts.host.info.platformFamily\") # Simple nested path lookup(\"facts.network.interfaces.0.name\") # Array index lookup(\"data.packages.#\") # Array length CLI Usage These expressions work on the CLI:\n$ ccm ensure package '{{ lookup(\"data.package_name\", \"httpd\") }}' This fetches package_name from the data and defaults to httpd if not found.\nFacts CCM includes a built-in fact resolver that gathers system information. To see available facts:\n$ ccm facts # All facts as JSON $ ccm facts host # Query specific path $ ccm facts --yaml # Output as YAML Access facts in expressions using {{ Facts.host.info.platformFamily }} or {{ lookup('facts.host.info.platformFamily') }}.\nHiera Data for CLI Hiera data is resolved using the Choria Hierarchical Data Resolver. By default, data is read from ./.hiera, or you can specify a file with --hiera.\nNote This applies to ccm ensure commands. The ccm apply command uses manifests that contain their own Hiera data.\nHiera Data Sources Hiera data can be loaded from:\nLocal file: ./.hiera or path specified with --hiera Key-Value store: --hiera kv://BUCKET/key (requires --context for NATS) HTTP(S): --hiera https://example.com/data.yaml (supports Basic Auth via URL credentials) Merge Strategies The hierarchy.merge setting controls how overrides are applied:\nfirst (default): Stops at the first matching override deep: Deep merges all matching overrides in order Example Given this file stored in ./.hiera:\nhierarchy: order: - os:{{ lookup('facts.host.info.platformFamily') }} merge: first data: package_name: \"\" overrides: os:debian: package_name: apache2 os:rhel: package_name: httpd Running ccm ensure package '{{ lookup(\"data.package_name\") }}' installs httpd on RHEL-based systems and apache2 on Debian-based systems.\nNote See the Hiera section for details on configuring Hiera data in NATS.\nEnvironment The shell environment and variables defined in ./.env can be accessed in two ways:\n# Direct access home_dir: \"{{ Environ.HOME }}\" # Via lookup (with default value) my_var: \"{{ lookup('environ.MY_VAR', 'default') }}\" The .env file uses standard KEY=value format, one variable per line.",
    "description": "Just like applications need data to vary their behavior and configure their environments, so do Configuration Management tools.\nFor this reason, I wrote extlookup and hiera years ago for the Puppet community. Despite CCM’s minimal focus, we still need data to vary behavior.\nData can be used for:\nConfiguring resource names that differ between operating systems (e.g., httpd vs apache2) Setting different configuration values depending on environment, role, or other dimensions Deciding whether environments should have something installed (e.g., development vs production) CCM supports various data sources:",
    "tags": [],
    "title": "Data",
    "uri": "/data/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "CCM is designed as a CLI-first tool. Each resource type has its own subcommand under ccm ensure, with required inputs as arguments and optional settings as flags.\nThe ccm ensure commands are idempotent, making them safe to run multiple times in shell scripts.\nUse ccm --help and ccm \u003ccommand\u003e --help to explore available commands and options.\nManaging a Single Resource Managing a single resource is straightforward.\n$ ccm ensure package zsh 5.8 This ensures the package zsh is installed at version 5.8.\nTo view the current state of a resource:\n$ ccm status package zsh Managing Multiple Resources When managing multiple resources in a script, create a session first. The session records the outcome of each resource, enabling features like refreshing a service when a file changes.\n#!/bin/bash eval \"$(ccm session new)\" trap 'rm -rf -- \"$CCM_SESSION_STORE\"' EXIT ccm ensure package httpd ccm ensure file /etc/httpd/conf/httpd.conf .... --require package#httpd ccm ensure service httpd --subscribe file#/etc/httpd/conf/httpd.conf ccm session report This creates a temporary directory for session state. If the file resource changes, the service restarts automatically.\nIf you prefer not to eval command output, use: export CCM_SESSION_STORE=$(mktemp -d)\nData in the CLI As covered in the data section, commands automatically read ./.env and ./.hiera files, merging that data into the session.\nUse the --hiera flag or CCM_HIERA_DATA environment variable to specify a different data file.\nWith data loaded, you can access:\n{{ lookup(\"data.my_data_key\") }} for Hiera data {{ lookup(\"env.MY_ENV_VAR\") }} for environment variables {{ lookup(\"facts.host.info.platformFamily\") }} for system facts Example using Hiera data:\n$ ccm ensure package '{{ lookup(\"data.package\") }}' '{{ lookup(\"data.version\") }}' Expressions use the Expr Language, enabling complex logic:\n$ ccm ensure package '{{ lookup(\"facts.host.info.platformFamily\") == \"rhel\" ? \"httpd\" : \"apache2\" }}' WARN package#httpd changed ensure=present runtime=14.509s provider=dnf For complex conditional logic, we recommend using Hiera data with hierarchy overrides instead.\nApplying Manifests For non-shell script usage use YAML manifests with ccm apply:\nSee YAML Manifests for manifest format details.\nViewing System Facts CCM gathers system facts that can be used in templates and conditions:\n# Show all facts as JSON $ ccm facts # Show facts as YAML $ ccm facts --yaml # Query specific facts using gjson syntax $ ccm facts host.info.platformFamily Resolving Hiera Data The ccm hiera command helps debug and test Hiera data resolution:\n# Resolve a Hiera file with system facts $ ccm hiera parse data.yaml -S # Resolve with custom facts $ ccm hiera parse data.yaml os=linux env=production # Query a specific key from the result $ ccm hiera parse data.yaml --query packages",
    "description": "CCM is designed as a CLI-first tool. Each resource type has its own subcommand under ccm ensure, with required inputs as arguments and optional settings as flags.\nThe ccm ensure commands are idempotent, making them safe to run multiple times in shell scripts.\nUse ccm --help and ccm \u003ccommand\u003e --help to explore available commands and options.\nManaging a Single Resource Managing a single resource is straightforward.",
    "tags": [],
    "title": "Shell Usage",
    "uri": "/cli/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "A manifest is a YAML file that combines data, hierarchy configuration, and resources in a single file.\nManifests support template expressions but not procedural logic. Think of them as declarative configuration similar to multi-resource shell scripts.\nNote A JSON Schema for manifests is available at https://choria.io/schemas/ccm/v1/manifest.json. Configure your editor to use this schema for completion and validation.\nManifest Structure A manifest contains these top-level sections:\nSection Description data Input data (like module parameters) hierarchy Lookup order and merge strategy for overrides overrides Data overrides keyed by hierarchy entries ccm Resource definitions and execution options The manifest is resolved using the Choria Hierarchical Data Resolver.\nFull Example Input Data Define input data like parameters for a module:\ndata: package_name: \"httpd\" Resources Define resources to manage in the ccm section:\nccm: resources: - package: - \"{{ lookup('data.package_name') }}\": ensure: latest Configure Hierarchy Configure a hierarchy to vary data by dimensions like OS platform:\nhierarchy: order: - os:{{ lookup('facts.host.info.platformFamily') }} This looks for overrides in os:rhel, os:debian, etc.\nOverrides Provide platform-specific data overrides:\noverrides: os:debian: package_name: apache2 Applying Manifests The complete manifest:\ndata: package_name: \"httpd\" ccm: resources: - package: - \"{{ lookup('data.package_name') }}\": ensure: latest hierarchy: order: - os:{{ lookup('facts.host.info.platformFamily') }} overrides: os:debian: package_name: apache2 Apply the manifest with ccm apply. The first run makes changes; subsequent runs are stable:\n$ ccm apply manifest.yaml INFO Creating new session record resources=1 WARN package#httpd changed ensure=latest runtime=3.560699287s provider=dnf $ ccm apply manifest.yaml INFO Creating new session record resources=1 INFO package#httpd stable ensure=latest runtime=293.448824ms provider=dnf To preview the fully resolved manifest without applying it:\n$ ccm apply manifest.yaml --render data: package_name: apache2 resources: - package: - apache2: ensure: latest Pre and Post Messages Display messages before and after manifest execution:\nccm: pre_message: | Starting configuration update... post_message: | Configuration complete. resources: - ... Both are optional.\nOverriding Data Override or augment manifest data with an external Hiera source:\n$ ccm apply manifest.yaml --hiera kv://CCM/common Supported sources include local files, KV stores (kv://), and HTTP(S) URLs.\nSetting Defaults Reduce repetition by setting defaults for resources of the same type:\nccm: resources: - file: - defaults: owner: app group: app mode: \"0644\" ensure: present - /app/config/file.conf: source: file.conf - /app/bin/app: source: app.bin mode: \"0700\" - file: - /etc/motd: ensure: present source: motd.txt owner: root group: root mode: \"0644\" The first two files inherit the defaults values. The /app/bin/app file overrides just the mode. The /etc/motd file is a separate resource block, so defaults do not apply.\nTemplating Manifests support template expressions like {{ lookup(\"key\") }} for adjusting values. These expressions cannot generate new resources; they only modify values in valid YAML.\nAvailable Variables Templates have access to:\nVariable Description Facts System facts Data Resolved Hiera data Environ Environment variables Generating Resources with Jet Templates To dynamically generate resources from data, use Jet Templates.\nGiven this data:\ndata: common_packages: - zsh - vim-enhanced - nagios-plugins-all - tar - nmap-ncat Reference a Jet template file instead of inline resources:\nccm: resources_jet_file: resources.jet Create the template file:\n{* resources.jet *} [[ range Data.common_packages ]] - package: - [[ . ]]: ensure: present [[ end ]] Note The template file must be in the same directory as the manifest.\nThe template receives the fully resolved Hiera data, plus Facts and Environ.\nFailure Handling By default, if a resource fails, the apply continues to the next resource.\nFail on Error To stop execution on the first failure, set fail_on_error:\nccm: fail_on_error: true resources: - exec: - /usr/bin/false: {} - /usr/bin/true: {} The second resource is never executed:\n$ ccm apply manifest.yaml INFO Executing manifest manifest=manifest.yaml resources=2 ERROR exec#/usr/bin/false failed ensure=present runtime=3ms provider=posix errors=failed to reach desired state exit code 1 WARN Terminating manifest execution due to failed resource Resource Dependencies Use the require property to ensure a resource only runs after its dependencies succeed:\nccm: resources: - package: - httpd: ensure: present - file: - /etc/httpd/conf.d/custom.conf: ensure: present content: \"Listen 8080\" owner: root group: root mode: \"0644\" require: - package#httpd If the required resource fails, the dependent resource is skipped.\nDry Run (Noop Mode) Preview changes without applying them:\n$ ccm apply manifest.yaml --noop Note Noop mode cannot always detect cascading effects. If one resource change would affect a later resource, that dependency may not be reflected in the dry run.\nHealth Check Only Mode Run only health checks without applying resources:\n$ ccm apply manifest.yaml --monitor-only This is useful for verifying system state without making changes.\nManifests in NATS Object Store Manifests can be stored in NATS Object Stores, avoiding the need to distribute files locally.\nConfigure a NATS context for authentication:\n$ nats context add ccm --server nats.example.org --user ccm --password s3cret --description \"CCM Configuration Store\" Create an Object Store:\n$ nats obj add CCM --replicas 3 --context ccm Create a manifest with supporting files:\n$ mkdir /tmp/manifest $ echo 'CCM Managed' \u003e /tmp/manifest/motd $ cat \u003e /tmp/manifest/manifest.yaml \u003c\u003c 'EOF' ccm: resources: - file: - /etc/motd: ensure: present source: motd owner: root group: root mode: \"0644\" EOF Package and upload to the Object Store:\n$ tar -C /tmp/manifest/ -cvzf /tmp/manifest.tgz . $ nats obj put CCM manifest.tgz --context ccm Apply the manifest:\n$ ccm apply obj://CCM/manifest.tgz --context ccm INFO Using manifest from Object Store in temporary directory bucket=CCM file=manifest.tgz INFO file#/etc/motd stable ensure=present runtime=0s provider=posix Manifests on Web Servers Store gzipped tar archives on a web server and apply them directly:\n$ ccm apply https://example.net/manifest.tar.gz INFO Executing manifest manifest=https://example.net/manifest.tar.gz resources=1 INFO file#/etc/motd stable ensure=present runtime=0s provider=posix HTTP Basic Auth is supported via URL credentials:\n$ ccm apply https://user:pass@example.net/manifest.tar.gz Additional Facts Provide additional facts from the command line or a file:\n# Individual facts $ ccm apply manifest.yaml --fact env=production --fact region=us-east # Facts from a file $ ccm apply manifest.yaml --facts custom-facts.yaml Facts from these sources are merged with system facts, with command-line facts taking precedence.",
    "description": "A manifest is a YAML file that combines data, hierarchy configuration, and resources in a single file.\nManifests support template expressions but not procedural logic. Think of them as declarative configuration similar to multi-resource shell scripts.\nNote A JSON Schema for manifests is available at https://choria.io/schemas/ccm/v1/manifest.json. Configure your editor to use this schema for completion and validation.\nManifest Structure A manifest contains these top-level sections:",
    "tags": [],
    "title": "YAML Manifests",
    "uri": "/yamlmanifests/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "For certain use cases, it is useful to run YAML Manifests continuously. For example, you might not want to manage your dotfiles automatically (allowing for local modifications), but you do want to keep Docker up to date.\nThe CCM Agent runs manifests continuously, loading them from local files, Object Storage, or HTTP(S) URLs, with Key-Value data overlaid.\nIn time, the Agent will become a key part of a service registry system, allowing for continuous monitoring of managed resources and sharing that state into a registry—enabling other nodes to use file resources to create configurations that combine knowledge of all nodes.\nRun Modes The agent supports two modes of operation that combine to be efficient and fast-reacting:\nFull manifest apply: Manages the complete state of every resource Health check mode: Runs only Monitoring checks, which can trigger a full manifest apply as remediation By enabling both modes, you can run health checks very frequently (even at 10- or 20-second intervals) while keeping full Configuration Management runs less frequent (every few hours).\nEnabling both modes is optional but recommended. We also recommend adding health checks to your key resources.\nSupported Manifest and Data Sources Manifest Sources Manifests can be loaded from:\nLocal file: /path/to/manifest.yaml Object Storage: obj://bucket/key.tar.gz HTTP(S): https://example.com/manifest.tar.gz (supports Basic Auth via URL credentials) Remote sources (Object Storage and HTTP) must be .tar.gz archives containing a manifest.yaml file, templates and file sources.\nExternal Data Sources For Hiera data resolution, the agent supports:\nLocal file: file:///path/to/data.yaml Key-Value store: kv://bucket/key HTTP(S): https://example.com/data.yaml Logical Flow The agent continuously runs and manages manifests as follows:\nAt startup, the agent fetches data and gathers facts Starts a worker for each manifest source Each worker starts watchers to download and manage the manifest (polling every 30 seconds for remote sources) Triggers workers at the configured interval for a full apply Each run updates facts (minimum 2-minute interval) and data Applies each manifest serially Triggers workers at the configured health check interval Health check runs do not update facts or data Runs health checks for each manifest serially If any health checks are critical (not warning), the agent triggers a full apply for that worker In the background, object stores and HTTP sources are watched for changes. Updates trigger immediate apply runs with exponential backoff retry on failures.\nPrometheus Metrics When monitor_port is configured, the agent exposes Prometheus metrics on /metrics. These metrics can be used to monitor agent health, track resource states and events, and observe health check statuses.\nAgent Metrics Metric Type Labels Description choria_ccm_agent_apply_duration_seconds Summary manifest Time taken to apply manifests choria_ccm_agent_healthcheck_duration_seconds Summary manifests Time taken for health check runs choria_ccm_agent_healthcheck_remediations_count Counter manifest Health checks that triggered remediation choria_ccm_agent_data_resolve_duration_seconds Summary - Time taken to resolve external data choria_ccm_agent_data_resolve_error_count Counter url Data resolution failures choria_ccm_agent_facts_resolve_duration_seconds Summary - Time taken to resolve facts choria_ccm_agent_facts_resolve_error_count Counter - Facts resolution failures choria_ccm_agent_manifest_fetch_count Counter manifest Remote manifest fetches choria_ccm_agent_manifest_fetch_error_count Counter manifest Remote manifest fetch failures Resource Metrics Metric Type Labels Description choria_ccm_manifest_apply_duration_seconds Summary source Time taken to apply an entire manifest choria_ccm_resource_apply_duration_seconds Summary type, provider, name Time taken to apply a resource choria_ccm_resource_state_total_count Counter type, name Total resources processed choria_ccm_resource_state_stable_count Counter type, name Resources in stable state choria_ccm_resource_state_changed_count Counter type, name Resources that changed choria_ccm_resource_state_refreshed_count Counter type, name Resources that were refreshed choria_ccm_resource_state_failed_count Counter type, name Resources that failed choria_ccm_resource_state_error_count Counter type, name Resources with errors choria_ccm_resource_state_skipped_count Counter type, name Resources that were skipped choria_ccm_resource_state_noop_count Counter type, name Resources in noop mode Health Check Metrics Metric Type Labels Description choria_ccm_healthcheck_duration_seconds Summary type, name, check Time taken for health checks choria_ccm_healthcheck_status_count Counter type, name, status, check Health check results by status Facts Metrics Metric Type Labels Description choria_ccm_facts_gather_duration_seconds Summary - Time taken to gather system facts Configuration The agent is included in the ccm binary. To use it, create a configuration file and enable the systemd service.\nThe configuration file is located at /etc/choria/ccm/config.yaml:\n# CCM Agent Configuration Example # Time between scheduled manifest apply runs. # Must be at least 30s. Defaults to 5m. interval: 5m # Time between health check runs. # When set, health checks run independently of apply runs and can trigger # remediation applies when critical issues are detected. # Omit to disable periodic health checks. health_check_interval: 1m # List of manifest sources to apply. Each source creates a separate worker. # Supported formats: # - Local file: /path/to/manifest.yaml # - Object store: obj://bucket/key.tar.gz # - HTTP(S): https://example.com/manifest.tar.gz # - HTTP with Basic Auth: https://user:pass@example.com/manifest.tar.gz # Remote sources must be .tar.gz archives containing a manifest.yaml file. manifests: - /etc/choria/ccm/manifests/base.yaml - obj://ccm-manifests/app.tar.gz - https://config.example.com/manifests/web.tar.gz # Logging level: debug, info, warn, error log_level: info # NATS context for authentication. Defaults to 'CCM'. nats_context: CCM # Optional URL for external Hiera data resolution. # Supported formats: file://, kv://, http(s):// # The resolved data is merged into the manifest data context. external_data_url: kv://ccm-data/common # Directory for caching remote manifest sources. # Defaults to /etc/choria/ccm/source. cache_dir: /etc/choria/ccm/source # Port for Prometheus metrics endpoint (/metrics). # Set to 0 or omit to disable. monitor_port: 9100 After configuring, start the service:\nccm ensure service ccm-agent running --enable",
    "description": "For certain use cases, it is useful to run YAML Manifests continuously. For example, you might not want to manage your dotfiles automatically (allowing for local modifications), but you do want to keep Docker up to date.\nThe CCM Agent runs manifests continuously, loading them from local files, Object Storage, or HTTP(S) URLs, with Key-Value data overlaid.\nIn time, the Agent will become a key part of a service registry system, allowing for continuous monitoring of managed resources and sharing that state into a registry—enabling other nodes to use file resources to create configurations that combine knowledge of all nodes.",
    "tags": [],
    "title": "Agent",
    "uri": "/agent/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "By default, CCM verifies resource health using the resource’s native state. For example, if a service should be running and systemd reports it as running, CCM considers it healthy.\nFor deeper validation, all resources support custom health checks. These checks run after a resource is managed and can verify that the resource is functioning correctly, not just present.\nHealth Check Properties Property Description Default command Command to execute (required) - name Name for logging and metrics Command base name tries Number of attempts before failing 1 try_sleep Duration to wait between retry attempts 1s timeout Maximum time for command execution No timeout format Output format interpretation nagios Nagios Format Health checks use Nagios plugin conventions for exit codes:\nExit Code Status Description 0 OK Check passed 1 WARNING Check passed with warnings (non-critical) 2 CRITICAL Check failed 3+ UNKNOWN Check could not determine status Example - service: - httpd: ensure: running enable: true health_checks: - name: check_http command: /usr/lib64/nagios/plugins/check_http -H localhost -p 80 --expect \"Acme Inc\" tries: 5 try_sleep: 1s timeout: 10s This example verifies that the web server responds with content containing “Acme Inc”. If the check fails, it retries up to 5 times with 1 second between attempts.\nCLI Usage Health checks can be added to ccm ensure commands:\n$ ccm ensure service httpd running \\ --check '/usr/lib64/nagios/plugins/check_http -H localhost -p 80' \\ --check-tries 5 \\ --check-sleep 1s The CLI supports a single health check per resource. For multiple health checks, use a manifest.\nAgent Integration When running the Agent with health_check_interval configured, health checks run independently of full manifest applies. If any health check returns a CRITICAL status, the agent triggers a remediation apply for that manifest.",
    "description": "By default, CCM verifies resource health using the resource’s native state. For example, if a service should be running and systemd reports it as running, CCM considers it healthy.\nFor deeper validation, all resources support custom health checks. These checks run after a resource is managed and can verify that the resource is functioning correctly, not just present.\nHealth Check Properties Property Description Default command Command to execute (required) - name Name for logging and metrics Command base name tries Number of attempts before failing 1 try_sleep Duration to wait between retry attempts 1s timeout Maximum time for command execution No timeout format Output format interpretation nagios Nagios Format Health checks use Nagios plugin conventions for exit codes:",
    "tags": [],
    "title": "Monitoring",
    "uri": "/monitoring/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
