var relearn_searchindex = [
  {
    "breadcrumb": "",
    "content": "Configuration Management systems typically focus on full-system management - optimized for hundreds or thousands of resources per node. This makes them complex, dependency-heavy, and poorly suited to ad hoc systems where each node is a unique snowflake.\nCCM is a small-scale Configuration Management system designed to meet users where they are - enabling experimentation, R\u0026D, and exploration without the overhead of full-system management while still following sound Configuration Management principles.\nWe focus on great UX, immediate feedback, and interactive use with minimal friction.\nSmall and Focused\rEmbraces the popular package-config-service style of Configuration Management.\nFocused on the needs of a single application or unit of software.\nMinimal design for easy adoption, experimentation, and integration with tools like LLMs.\nLoves Snowflakes\rBrings true Configuration Management principles to ad-hoc systems, enabling use cases where traditional CM fails.\nUse management bundles in an à la carte fashion to quickly bring experimental infrastructure to a known state.\nExternal Data\rRich, Hierarchical Data and Facts accessible in the command line, scripts, and manifests.\nDemocratizes and opens the data that drives systems management to the rest of your stack.\nNo Dependencies\rZero-dependency binaries, statically linked and fast.\nEasy deployment in any environment without the overhead-cost of traditional CM.\nEmbraces a Just Works philosophy with no, or minimal, configuration.\nOptional Networking\rOptional Network infrastructure needed only when your needs expand.\nChoose from simple webservers to clustered, reliable, Object and Key-Value stores using technology you already know.\nEverywhere\rGreat at the CLI, shell scripts, YAML manifests, Choria Agents, and Go applications.\nScales from single IoT Raspberry Pi 3 to millions of nodes.\nIntegrates easily with other software via SDK or Unix-like APIs.\nShell Example Here we do a package-config-service style deployment using a shell script. The script is safe to run multiple times as the CCM commands are all idempotent.\n#!/bin/bash eval $(ccm session new) ccm ensure package httpd ccm ensure file /etc/httpd/conf.d/listen.conf content=\"Listen 8080\" ccm ensure service httpd --subscribe file#/etc/httpd/conf.d/listen.conf ccm session report When run, this will create a session in a temporary directory and manage the resources. If the file resource changes after initial deployment, the service will restart.\nWe support dynamic data on the CLI, ccm will read .env files and .hiera files and feed that into the runtime data. Using this even shell scripts can easily gain access to rich data.\n$ cat .env package_name=\"httpd\" $ ccm ensure package '{{ Data.package_name }}' INFO package#httpd stable ensure=present runtime=8ms provider=dnf Manifest Example Taking the example above, here is what it looks like in a manifest, complete with multi-OS support using Hierarchical Data and System Facts:\ndata: package_name: httpd service_name: httpd ccm: resources: - package: - \"{{ Data.package_name }}\": ensure: present - file: - \"/etc/httpd/conf.d/listen.conf\": ensure: present content: | Listen 8080 - service: - \"{{ Data.service_name }}\": ensure: running enable: true subscribe: - file#/etc/httpd/conf.d/listen.conf hierarchy: order: - os:{{ lookup('facts.host.info.platformFamily') }} overrides: os:debian: package_name: apache2 service_name: apache2 Here we define the inputs in data and the Hiera hierarchy along with OS-specific overrides. The data is referenced in the manifest using the {{ Data.package_name }} syntax.\nStatus This is a new project seeking contributors and early adopters.\nCurrently, only archive, exec, file, service, and package resources are implemented, with support limited to dnf, apt and systemd.\nThe CLI and shell interaction have reached a mature state. Next, we’re exploring network-related features and deeper monitoring integration.",
    "description": "Configuration Management systems typically focus on full-system management - optimized for hundreds or thousands of resources per node. This makes them complex, dependency-heavy, and poorly suited to ad hoc systems where each node is a unique snowflake.\nCCM is a small-scale Configuration Management system designed to meet users where they are - enabling experimentation, R\u0026D, and exploration without the overhead of full-system management while still following sound Configuration Management principles.",
    "tags": [],
    "title": "Introduction",
    "uri": "/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Design Documents \u003e Package Type",
    "content": "This document describes the implementation details of the APT package provider for Debian-based systems.\nEnvironment All commands are executed with the following environment variables to ensure non-interactive operation:\nVariable Value Purpose DEBIAN_FRONTEND noninteractive Prevents dpkg from prompting for user input APT_LISTBUGS_FRONTEND none Suppresses apt-listbugs prompts APT_LISTCHANGES_FRONTEND none Suppresses apt-listchanges prompts Concurrency A global package lock (model.PackageGlobalLock) is held during all command executions to prevent concurrent apt/dpkg operations within the same process. This prevents lock contention on /var/lib/dpkg/lock.\nOperations Status Check Command:\ndpkg-query -W -f='${Package} ${Version} ${Architecture} ${db:Status-Status}' \u003cpackage\u003e Behavior:\nExit code 0 with installed status → Package is present, returns version info Exit code non-zero OR status not installed → Package is absent Package States: The db:Status-Status field can return various values. Only installed is treated as present:\nStatus Treated As Description installed Present Package fully installed config-files Absent Removed but config files remain half-installed Absent Installation started but failed half-configured Absent Configuration failed unpacked Absent Unpacked but not configured not-installed Absent Not installed Treating non-installed states as absent allows apt-get install to repair broken installations.\nInstall Ensure Present:\napt-get install -y -q -o DPkg::Options::=--force-confold \u003cpackage\u003e Ensure Latest:\napt-cache policy \u003cpackage\u003e # Get candidate version apt-get install -y -q -o DPkg::Options::=--force-confold \u003cpackage\u003e=\u003cversion\u003e Specific Version:\napt-get install -y -q -o DPkg::Options::=--force-confold --allow-downgrades \u003cpackage\u003e=\u003cversion\u003e Flags:\nFlag Purpose -y Assume yes to prompts -q Quiet output -o DPkg::Options::=--force-confold Keep existing config files on upgrade --allow-downgrades Allow installing older versions (specific version only) Upgrade Delegates to Install() with the target version. The --allow-downgrades flag is only added for specific version requests, not for latest.\nDowngrade Delegates to Install() with the target version. The --allow-downgrades flag enables this operation.\nUninstall Command:\napt-get -q -y remove \u003cpackage\u003e Note: Uses remove not purge, so configuration files are preserved. A subsequent install will find existing config files.\nLatest Available Version Command:\napt-cache policy \u003cpackage\u003e Parsing: Extracts the Candidate: line from output.\nExample output:\nzsh: Installed: 5.9-8+b18 Candidate: 5.9-8+b18 Version table: *** 5.9-8+b18 500 500 http://deb.debian.org/debian trixie/main amd64 Packages 100 /var/lib/dpkg/status Version Comparison Version comparison follows the Debian Policy Manual algorithm.\nVersion Format [epoch:]upstream_version[-debian_revision] Component Required Description epoch No Integer, default 0. Higher epoch always wins. upstream_version Yes The main version from upstream debian_revision No Debian-specific revision Examples:\n1.0 → epoch=0, upstream=1.0, revision=\"\" 1:2.0-3 → epoch=1, upstream=2.0, revision=3 2:1.0.0+git-20190109-0ubuntu2 → epoch=2, upstream=1.0.0+git-20190109, revision=0ubuntu2 Comparison Algorithm Compare epochs numerically - Higher epoch wins regardless of other components\nCompare upstream_version and debian_revision using the Debian string comparison:\nThe string is processed left-to-right in segments:\na. Tildes (~) - Compared first. More tildes = earlier version. Tilde sorts before everything, even empty string.\n1.0~alpha \u003c 1.0 (tilde before empty) 1.0~~ \u003c 1.0~ (more tildes = earlier) b. Letters (A-Za-z) - Compared lexically (ASCII order)\nLetters sort before non-letters c. Non-letters (., +, -) - Compared lexically\nd. Digits - Compared numerically (not lexically)\n9 \u003c 13 (numeric comparison) These steps repeat until a difference is found or both strings are exhausted.\nComparison Examples A B Result Reason 1.0 2.0 A \u003c B Numeric comparison 1:1.0 2.0 A \u003e B Epoch 1 \u003e epoch 0 1.0~alpha 1.0 A \u003c B Tilde sorts before empty 1.0~alpha 1.0~beta A \u003c B Lexical: alpha \u003c beta 1.0.1 1.0.2 A \u003c B Numeric: 1 \u003c 2 1.0-1 1.0-2 A \u003c B Revision comparison 1.0a 1.0- A \u003c B Letters sort before non-letters Implementation The version comparison is implemented in version.go, ported from Puppet’s Puppet::Util::Package::Version::Debian module. It provides:\nParseVersion(string) - Parse a version string into components CompareVersionStrings(a, b) - Compare two version strings directly Version.Compare(other) - Compare parsed versions (-1, 0, 1) Helper methods: LessThan, GreaterThan, Equal, etc.",
    "description": "This document describes the implementation details of the APT package provider for Debian-based systems.\nEnvironment All commands are executed with the following environment variables to ensure non-interactive operation:\nVariable Value Purpose DEBIAN_FRONTEND noninteractive Prevents dpkg from prompting for user input APT_LISTBUGS_FRONTEND none Suppresses apt-listbugs prompts APT_LISTCHANGES_FRONTEND none Suppresses apt-listchanges prompts Concurrency A global package lock (model.PackageGlobalLock) is held during all command executions to prevent concurrent apt/dpkg operations within the same process. This prevents lock contention on /var/lib/dpkg/lock.",
    "tags": [],
    "title": "APT Provider",
    "uri": "/design/package/apt/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Design Documents",
    "content": "This document describes the design of the archive resource type for downloading and extracting archives.\nOverview The archive resource manages remote archives with three phases:\nDownload: Fetch archive from a URL to local filesystem Extract: Unpack archive contents to a target directory Cleanup: Optionally remove the archive file after extraction These phases are conditional based on current state and configuration.\nProvider Interface Archive providers must implement the ArchiveProvider interface:\ntype ArchiveProvider interface { model.Provider Download(ctx context.Context, properties *model.ArchiveResourceProperties, log model.Logger) error Extract(ctx context.Context, properties *model.ArchiveResourceProperties, log model.Logger) error Status(ctx context.Context, properties *model.ArchiveResourceProperties) (*model.ArchiveState, error) } Method Responsibilities Method Responsibility Status Query archive file existence, checksum, attributes, and creates file Download Fetch archive from URL, verify checksum, set ownership Extract Unpack archive contents to extract parent directory Status Response The Status method returns an ArchiveState containing:\ntype ArchiveState struct { CommonResourceState Metadata *ArchiveMetadata } type ArchiveMetadata struct { Name string // Archive file path Checksum string // SHA256 hash of archive ArchiveExists bool // Whether archive file exists CreatesExists bool // Whether creates marker file exists Owner string // Archive file owner Group string // Archive file group MTime time.Time // Modification time Size int64 // File size in bytes Provider string // Provider name (e.g., \"http\") } The Ensure field in CommonResourceState is set to:\npresent if the archive file exists absent if the archive file does not exist Available Providers Provider Source Documentation http HTTP/HTTPS URLs HTTP Ensure States Value Description present Archive must be downloaded (and optionally extracted) absent Archive file must not exist Supported Archive Formats Extension Description .tar.gz, .tgz Gzip-compressed tar archive .tar Uncompressed tar archive .zip ZIP archive The URL and local file name must have matching archive type extensions.\nApply Logic ┌─────────────────────────────────────────┐ │ Get current state via Status() │ └─────────────────┬───────────────────────┘ │ ▼ ┌─────────────────────────────────────────┐ │ Is current state desired state? │ └─────────────────┬───────────────────────┘ Yes │ No ▼ │ ┌───────────┐ │ │ No change │ │ └───────────┘ │ ▼ ┌─────────────────────────┐ │ What is desired ensure? │ └─────────────┬───────────┘ │ ┌───────────────┴───────────────┐ │ absent │ present ▼ ▼ ┌───────────────┐ ┌─────────────────────┐ │ Remove archive│ │ Download needed? │ │ file │ │ (checksum mismatch │ └───────────────┘ │ or file missing) │ └─────────┬───────────┘ Yes │ No ▼ │ ┌───────────┐ │ │ Download │ │ └─────┬─────┘ │ │ │ ▼ ▼ ┌─────────────────────────┐ │ Extract needed? │ │ (extract_parent set AND │ │ (download occurred OR │ │ creates file missing))│ └─────────┬───────────────┘ Yes │ No ▼ │ ┌───────────┐ │ │ Extract │ │ └─────┬─────┘ │ │ │ ▼ ▼ ┌─────────────────────────┐ │ Cleanup enabled? │ └─────────┬───────────────┘ Yes │ No ▼ ▼ ┌───────────┐ ┌───────┐ │ Remove │ │ Done │ │ archive │ └───────┘ └───────────┘ Idempotency The archive resource uses multiple checks for idempotency:\nState Checks (in order) Ensure absent: Archive file must not exist Creates file: If creates is set, the marker file must exist Archive existence: If cleanup: false, archive must exist Owner/Group: Archive file attributes must match Checksum: If specified, archive checksum must match Decision Table Condition Stable? ensure: absent + archive missing Yes ensure: absent + archive exists No (remove) creates file exists Yes (skip all) creates file missing No (extract needed) cleanup: false + archive missing No (download needed) Archive checksum mismatch No (re-download needed) Archive owner/group mismatch No (re-download needed) Creates Property The creates property provides idempotency for extraction:\n- archive: - /tmp/app.tar.gz: url: https://example.com/app.tar.gz extract_parent: /opt/app creates: /opt/app/bin/app owner: root group: root Behavior:\nIf /opt/app/bin/app exists, skip download and extraction Useful when extracted files indicate successful prior extraction Prevents re-extraction on every run Cleanup Property The cleanup property removes the archive after extraction:\n- archive: - /tmp/app.tar.gz: url: https://example.com/app.tar.gz extract_parent: /opt/app creates: /opt/app/bin/app cleanup: true owner: root group: root Requirements:\nextract_parent must be set (cleanup only makes sense with extraction) creates must be set to track extraction state Behavior:\nAfter successful extraction, remove the archive file On subsequent runs, creates file prevents re-download Checksum Verification When checksum is specified:\n- archive: - /tmp/app.tar.gz: url: https://example.com/app.tar.gz checksum: \"a1b2c3d4...\" owner: root group: root Behavior:\nDownloaded file is verified against SHA256 checksum Existing file checksum is compared to detect changes Checksum mismatch triggers re-download Download fails if fetched content doesn’t match Authentication Archives support two authentication methods:\nBasic Authentication - archive: - /tmp/app.tar.gz: url: https://private.example.com/app.tar.gz username: deploy password: \"{{ lookup('data.password') }}\" owner: root group: root Custom Headers - archive: - /tmp/app.tar.gz: url: https://api.example.com/releases/app.tar.gz headers: Authorization: \"Bearer {{ lookup('data.token') }}\" owner: root group: root Required Properties Property Required Description url Yes Source URL for download owner Yes Username that owns the archive file group Yes Group that owns the archive file URL Validation URLs are validated during resource creation:\nMust be valid URL format Scheme must be http or https Path must end with supported archive extension Extension must match the name property extension Noop Mode In noop mode, the archive type:\nQueries current state normally Computes what actions would be taken Sets appropriate NoopMessage: “Would have downloaded” “Would have extracted” “Would have cleaned up” “Would have removed” Reports Changed: true if changes would occur Does not call provider Download/Extract methods Does not remove files Multiple actions are joined with “. \" (e.g., “Would have downloaded. Would have extracted”).\nDesired State Validation After applying changes (in non-noop mode), the type verifies the archive reached the desired state by calling Status() again and checking all conditions. If validation fails, ErrDesiredStateFailed is returned.",
    "description": "This document describes the design of the archive resource type for downloading and extracting archives.\nOverview The archive resource manages remote archives with three phases:\nDownload: Fetch archive from a URL to local filesystem Extract: Unpack archive contents to a target directory Cleanup: Optionally remove the archive file after extraction These phases are conditional based on current state and configuration.",
    "tags": [],
    "title": "Archive Type",
    "uri": "/design/archive/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Design Documents \u003e Archive Type",
    "content": "This document describes the implementation details of the HTTP archive provider for downloading and extracting archives from HTTP/HTTPS URLs.\nProvider Selection The HTTP provider is selected when:\nThe URL scheme is http or https The archive file extension is supported (.tar.gz, .tgz, .tar, .zip) The required extraction tool (tar or unzip) is available in PATH The IsManageable() function checks these conditions and returns a priority of 1 if all are met.\nOperations Download Process:\nParse the URL and add Basic Auth credentials if username/password provided Create HTTP request with custom headers (if specified) Execute GET request via util.HttpGetResponse() Verify HTTP 200 status code Create temporary file in the same directory as the target Set ownership on temp file before writing content Copy response body to temp file Verify checksum if provided Atomic rename temp file to target path Atomic Write Pattern:\n[parent dir]/archive-name-* (temp file) ↓ write content ↓ set owner/group ↓ verify checksum ↓ rename [parent dir]/archive-name (final file) The temp file is created in the same directory as the target to ensure os.Rename() is atomic (same filesystem).\nError Handling:\nCondition Behavior HTTP non-200 Return error with status code Write failure Clean up temp file, return error Checksum mismatch Clean up temp file, return error with expected vs actual Rename failure Temp file cleaned up by defer Authentication:\nMethod Implementation Basic Auth URL userinfo is passed to HttpGetResponse() which sets Authorization header Username/Password properties Embedded in URL before request: url.UserPassword(username, password) Custom Headers Added to request via http.Header.Add() Extract Process:\nValidate ExtractParent is set Create ExtractParent directory if it doesn’t exist (mode 0755) Determine archive type from file extension Execute appropriate extraction command Extraction Commands:\nExtension Command .tar.gz, .tgz tar -xzf \u003carchive\u003e -C \u003cextract_parent\u003e .tar tar -xf \u003carchive\u003e -C \u003cextract_parent\u003e .zip unzip -d \u003cextract_parent\u003e \u003carchive\u003e Command Execution:\nCommands are executed via model.CommandRunner.ExecuteWithOptions() with:\nOption Value Command tar or unzip Args Extraction flags and paths Cwd ExtractParent directory Timeout 1 minute Error Handling:\nCondition Behavior Unsupported extension Return “archive type not supported” error Command not found Runner returns error Non-zero exit code Return error with exit code and stderr Status Process:\nInitialize state with EnsureAbsent default Check if archive file exists via os.Stat() If exists: set EnsurePresent, populate metadata (size, mtime, owner, group, checksum) If Creates property set: check if creates file exists Metadata Collected:\nField Source Name From properties Provider “http” ArchiveExists os.Stat() success Size FileInfo.Size() MTime FileInfo.ModTime() Owner util.GetFileOwner() - resolves UID to username Group util.GetFileOwner() - resolves GID to group name Checksum util.Sha256HashFile() CreatesExists os.Stat() on Creates path Idempotency The provider supports idempotency through the type’s isDesiredState() function:\nState Checks (in order) Ensure Absent: If ensure: absent, archive must not exist Creates File: If Creates set and file doesn’t exist → not stable Archive Existence: If cleanup: false, archive must exist Owner/Group: Must match properties Checksum: If specified in properties, must match Note: When cleanup: true, the creates property is required (enforced at validation time).\nDecision Matrix Archive Exists Creates Exists Checksum Match Cleanup Stable? No No N/A false No (download needed) Yes No Yes false No (extract needed) Yes Yes Yes false Yes No Yes N/A true Yes Yes Yes Yes true No (cleanup needed) Checksum Verification Algorithm: SHA-256\nImplementation:\nsum, err := util.Sha256HashFile(tempFile) if sum != properties.Checksum { return fmt.Errorf(\"checksum mismatch, expected %q got %q\", properties.Checksum, sum) } Timing: Checksum is verified after download completes but before the atomic rename. This ensures:\nCorrupted downloads are never placed at the target path Temp file is cleaned up on mismatch Clear error message with both expected and actual checksums Security Considerations Credential Handling Credentials in URL are redacted in log messages via util.RedactUrlCredentials() Basic Auth header is set by Go’s http.Request.SetBasicAuth(), not manually constructed Archive Extraction Extraction uses system tar/unzip commands No path traversal protection beyond what the tools provide ExtractParent must be an absolute path (validated in model) Temporary Files Created with os.CreateTemp() using pattern \u003carchive-name\u003e-* Deferred removal ensures cleanup on all exit paths Ownership set before content written Platform Support The provider is Unix-only due to:\nDependency on util.GetFileOwner() which uses syscall for UID/GID resolution Dependency on util.ChownFile() for ownership management Timeouts Operation Timeout Configurable HTTP Download 1 minute (default in HttpGetResponse) No Archive Extraction 1 minute No Large archives may require increased timeouts in future versions.",
    "description": "This document describes the implementation details of the HTTP archive provider for downloading and extracting archives from HTTP/HTTPS URLs.\nProvider Selection The HTTP provider is selected when:\nThe URL scheme is http or https The archive file extension is supported (.tar.gz, .tgz, .tar, .zip) The required extraction tool (tar or unzip) is available in PATH The IsManageable() function checks these conditions and returns a priority of 1 if all are met.",
    "tags": [],
    "title": "HTTP Provider",
    "uri": "/design/archive/http/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Shell Usage",
    "content": "CCM provides a STDIN/STDOUT API for managing resources programmatically. This enables integration with external languages, allowing you to build DSLs in Ruby, Perl, Python, or any language that can execute processes and handle JSON or YAML.\nOverview The API uses a simple request/response pattern:\nSend a request to ccm ensure api pipe via STDIN Receive a response on STDOUT Both JSON and YAML formats are supported for requests. The response format is always JSON, but can be explicitly set to YAML using --yaml.\nCommand ccm ensure api pipe [--yaml] [--noop] [--facts \u003cfile\u003e] [--data \u003cfile\u003e] Flag Description --yaml Output response in YAML format instead of JSON --noop Dry-run mode; report what would change without making changes --facts \u003cfile\u003e Load additional facts from a YAML file --data \u003cfile\u003e Load Hiera-style data from a YAML file Request Format Requests must include a protocol identifier, resource type, and properties.\nNote JSON Schemas for these requests and responses are available at resource_ensure_request.json and resource_ensure_response.json.\nJSON Request { \"protocol\": \"io.choria.ccm.v1.resource.ensure.request\", \"type\": \"package\", \"properties\": { \"name\": \"nginx\", \"ensure\": \"present\" } } YAML Request protocol: io.choria.ccm.v1.resource.ensure.request type: package properties: name: nginx ensure: present Request Fields Field Required Description protocol Yes Must be io.choria.ccm.v1.resource.ensure.request type Yes Resource type example package properties Yes Resource properties (varies by type) Response Format Responses include a protocol identifier and either a state object (on success) or an error message.\nFor the full response structure, see ResourceEnsureApiResponse in the Go documentation. The state field contains a TransactionEvent.\nSuccessful Response { \"protocol\": \"io.choria.ccm.v1.resource.ensure.response\", \"state\": { \"protocol\": \"io.choria.ccm.v1.transaction.event\", \"event_id\": \"2abc123def456\", \"timestamp\": \"2026-01-28T10:30:00Z\", \"type\": \"package\", \"provider\": \"dnf\", \"name\": \"nginx\", \"requested_ensure\": \"present\", \"final_ensure\": \"1.24.0-1.el9\", \"duration\": 1500000000, \"changed\": true, \"failed\": false } } Error Response { \"protocol\": \"io.choria.ccm.v1.resource.ensure.response\", \"error\": \"invalid protocol \\\"wrong.protocol\\\"\" } Examples Install a Package echo '{ \"protocol\": \"io.choria.ccm.v1.resource.ensure.request\", \"type\": \"package\", \"properties\": { \"name\": \"htop\", \"ensure\": \"present\" } }' | ccm ensure api pipe Manage a Service cat \u003c\u003cEOF | ccm ensure api pipe protocol: io.choria.ccm.v1.resource.ensure.request type: service properties: name: nginx ensure: running EOF Create a File echo '{ \"protocol\": \"io.choria.ccm.v1.resource.ensure.request\", \"type\": \"file\", \"properties\": { \"name\": \"/etc/motd\", \"ensure\": \"present\", \"content\": \"Welcome to this server\\n\", \"owner\": \"root\", \"group\": \"root\", \"mode\": \"0644\" } }' | ccm ensure api pipe Dry-Run Mode echo '{ \"protocol\": \"io.choria.ccm.v1.resource.ensure.request\", \"type\": \"package\", \"properties\": { \"name\": \"vim\", \"ensure\": \"absent\" } }' | ccm ensure api pipe --noop Resource Types For detailed information about each resource type and its properties, see the Resource Documentation",
    "description": "CCM provides a STDIN/STDOUT API for managing resources programmatically. This enables integration with external languages, allowing you to build DSLs in Ruby, Perl, Python, or any language that can execute processes and handle JSON or YAML.\nOverview The API uses a simple request/response pattern:\nSend a request to ccm ensure api pipe via STDIN Receive a response on STDOUT Both JSON and YAML formats are supported for requests. The response format is always JSON, but can be explicitly set to YAML using --yaml.",
    "tags": [],
    "title": "JSON API",
    "uri": "/cli/api/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Design Documents \u003e Exec Type",
    "content": "This document describes the implementation details of the Posix exec provider for executing commands without a shell.\nProvider Selection The Posix provider is the default exec provider. It is always available and returns priority 1 for all exec resources unless a different provider is explicitly requested via the provider property.\nTo use the shell provider instead, specify provider: shell in the resource properties.\nComparison with Shell Provider Feature Posix Shell Shell invocation No Yes (/bin/sh -c) Pipes (|) Not supported Supported Redirections (\u003e, \u003c) Not supported Supported Shell builtins (cd, export) Not supported Supported Glob expansion Not supported Supported Command substitution ($(...)) Not supported Supported Argument parsing shellquote.Split() Passed as single string Security Lower attack surface Shell injection possible When to use Posix (default):\nSimple commands with arguments When shell features are not needed For better security (no shell injection risk) When to use Shell:\nCommands with pipes, redirections, or shell builtins Complex command strings When shell expansion is required Operations Execute Process:\nDetermine command source (Command property or Name if Command is empty) Parse command string into words using shellquote.Split() Extract command (first word) and arguments (remaining words) Execute via CommandRunner.ExecuteWithOptions() Optionally log output line-by-line if LogOutput is enabled Command Parsing:\nThe command string is parsed using github.com/kballard/go-shellquote, which handles:\nSyntax Example Result Simple words echo hello world [\"echo\", \"hello\", \"world\"] Single quotes echo 'hello world' [\"echo\", \"hello world\"] Double quotes echo \"hello world\" [\"echo\", \"hello world\"] Escaped spaces echo hello\\ world [\"echo\", \"hello world\"] Mixed quoting echo \"it's a test\" [\"echo\", \"it's a test\"] Execution Options:\nOption Source Description Command First word after parsing Executable path or name Args Remaining words Command arguments Cwd properties.Cwd Working directory Environment properties.Environment Additional env vars (KEY=VALUE format) Path properties.Path Search path for executables Timeout properties.ParsedTimeout Maximum execution time Output Logging:\nWhen LogOutput: true is set and a user logger is provided:\nscanner := bufio.NewScanner(bytes.NewReader(stdout)) for scanner.Scan() { log.Info(scanner.Text()) } Each line of stdout is logged as a separate Info message.\nError Handling:\nCondition Behavior Empty command string Return error: “no command specified” Invalid shell quoting Return parsing error (e.g., “Unterminated single quote”) Runner not configured Return error: “no command runner configured” Command execution fails Return error from runner Non-zero exit code Return exit code (not an error by itself) Status Process:\nCreate state with EnsurePresent (exec resources are always “present”) Check if Creates file exists via util.FileExists() Set CreatesSatisfied accordingly State Fields:\nField Value Protocol io.choria.ccm.v1.resource.exec.state ResourceType exec Name Resource name Ensure present (always) CreatesSatisfied true if Creates file exists Idempotency The exec resource achieves idempotency through multiple mechanisms:\nCreates File If creates is specified and the file exists, the command does not run:\n- exec: - /usr/bin/tar -xzf app.tar.gz: creates: /opt/app/bin/app cwd: /opt RefreshOnly Mode When refreshonly: true, the command only runs when triggered by a subscribed resource:\n- exec: - systemctl reload httpd: refreshonly: true subscribe: - file#/etc/httpd/conf/httpd.conf Exit Code Validation The returns property specifies acceptable exit codes (default: [0]):\n- exec: - /opt/app/healthcheck: returns: [0, 1, 2] # 0=healthy, 1=degraded, 2=warning Decision Flow ┌─────────────────────────────────────────┐ │ Should resource be applied? │ └─────────────────┬───────────────────────┘ │ ▼ ┌─────────────────────────────────────────┐ │ Subscribe triggered? │ │ (subscribed resource changed) │ └─────────────┬───────────────┬───────────┘ │ Yes │ No ▼ ▼ ┌─────────────────┐ ┌───────────────────┐ │ Execute command │ │ Creates satisfied? │ └─────────────────┘ └─────────┬─────────┘ │ ┌─────────┴─────────┐ │ Yes │ No ▼ ▼ ┌───────────────┐ ┌───────────────────┐ │ Skip (stable) │ │ RefreshOnly mode? │ └───────────────┘ └─────────┬─────────┘ │ ┌─────────┴─────────┐ │ Yes │ No ▼ ▼ ┌───────────────┐ ┌───────────────┐ │ Skip (stable) │ │ Execute │ └───────────────┘ └───────────────┘ Properties Validation The model validates exec properties before execution:\nProperty Validation name Must be parseable by shellquote (balanced quotes) timeout Must be valid duration format (e.g., 30s, 5m) subscribe Each entry must be type#name format path Each directory must be absolute (start with /) environment Each entry must be KEY=VALUE format with non-empty key and value Platform Support The Posix provider works on all platforms supported by Go’s os/exec package. It does not use any platform-specific system calls directly.\nThe command runner (model.CommandRunner) handles the actual process execution, which may have platform-specific implementations.\nSecurity Considerations No Shell Injection Unlike the shell provider, the posix provider does not invoke a shell. Arguments are passed directly to the executable, preventing shell injection attacks:\n# Safe with posix provider - $USER is passed literally, not expanded - exec: - /bin/echo $USER: provider: posix # Default # Potentially dangerous with shell provider - $USER is expanded - exec: - /bin/echo $USER: provider: shell Path Validation The path property only accepts absolute directory paths, preventing path traversal via relative paths.\nEnvironment Validation Environment variables must have non-empty keys and values, preventing injection of empty or malformed entries.",
    "description": "This document describes the implementation details of the Posix exec provider for executing commands without a shell.\nProvider Selection The Posix provider is the default exec provider. It is always available and returns priority 1 for all exec resources unless a different provider is explicitly requested via the provider property.\nTo use the shell provider instead, specify provider: shell in the resource properties.",
    "tags": [],
    "title": "Posix Provider",
    "uri": "/design/exec/posix/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Design Documents \u003e File Type",
    "content": "This document describes the implementation details of the Posix file provider for managing files and directories on Unix-like systems.\nProvider Selection The Posix provider is the default and only file provider. It is always available and returns priority 1 for all file resources.\nOperations Store (Create/Update File) Process:\nVerify parent directory exists Parse file mode from octal string Open source file if source property is set Create temporary file in the same directory as target Set file permissions on temp file Write content (from source file or contents property) Set ownership (chown) on temp file Close temp file Atomic rename temp file to target path Atomic Write Pattern:\n[parent dir]/\u003cbasename\u003e.* (temp file) ↓ chmod (set permissions) ↓ write content ↓ chown (set owner/group) ↓ close ↓ rename [parent dir]/\u003cbasename\u003e (final file) The temp file is created in the same directory as the target to ensure os.Rename() is atomic (same filesystem).\nContent Sources:\nProperty Behavior contents Write string directly to file (template-resolved) source Copy from local file path (adjusted for working directory) If both are empty, an empty file is created.\nError Handling:\nCondition Behavior Parent directory doesn’t exist Return error: “is not a directory” Invalid mode format Return error from strconv.ParseUint Source file not found Return error from os.Open Permission denied Return error from underlying syscall Rename failure Return error: “could not rename temporary file” CreateDirectory Process:\nParse file mode from octal string Create directory and parents via os.MkdirAll() Lookup numeric UID/GID from owner/group names Set permissions via os.Chmod() (ensures correct mode even if umask affected MkdirAll) Set ownership via os.Chown() Command Sequence:\nos.MkdirAll(dir, parsedMode) // Create directory tree os.Chmod(dir, parsedMode) // Ensure correct permissions os.Chown(dir, uid, gid) // Set ownership The explicit Chmod after MkdirAll is necessary because MkdirAll applies the process umask to the mode.\nStatus Process:\nInitialize state with default metadata Call os.Stat() on file path Based on result, populate state accordingly State Detection:\nos.Stat() Result Ensure Value Metadata File exists present Size, mtime, owner, group, mode, checksum Directory exists directory Size, mtime, owner, group, mode os.ErrNotExist absent None os.ErrPermission absent None (logged as warning) Other error (unchanged) None (logged as warning) Metadata Collection:\nField Source Name From properties Provider “posix” Size FileInfo.Size() MTime FileInfo.ModTime() Owner util.GetFileOwner() - resolves UID to username Group util.GetFileOwner() - resolves GID to group name Mode util.GetFileOwner() - octal string (e.g., “0644”) Checksum util.Sha256HashFile() - SHA256 hash (files only) Note: Checksum is only calculated for regular files, not directories.\nIdempotency The file resource achieves idempotency by comparing current state against desired state:\nState Checks The isDesiredState() function checks (in order):\nEnsure value matches - present, absent, or directory Content checksum matches - SHA256 of contents vs existing file (for files only) Owner matches - Username comparison Group matches - Group name comparison Mode matches - Octal permission string comparison Decision Flow ┌─────────────────────────────────────────┐ │ What is the desired ensure state? │ └─────────────────┬───────────────────────┘ │ ┌─────────────┼─────────────┬─────────────┐ │ absent │ directory │ present │ ▼ ▼ ▼ │ ┌───────────┐ ┌───────────┐ ┌───────────────┐ │ │ File │ │ Directory │ │ File exists? │ │ │ exists? │ │ exists? │ │ Content match?│ │ └─────┬─────┘ └─────┬─────┘ │ Owner match? │ │ │ │ │ Group match? │ │ Yes │ No Yes │ No │ Mode match? │ │ ▼ ▼ └───────┬───────┘ │ ┌─────────┐ ┌───────────┐ │ │ │ Remove │ │ Stable │ All Yes│ No │ │ file │ │ │ ▼ ▼ └─────────┘ └───────────┘ ┌───────────┐ ┌───────────┐ │ Stable │ │ Store │ └───────────┘ └───────────┘ Content Comparison For files with ensure: present:\nContent Source Checksum Calculation contents property Sha256HashBytes([]byte(contents)) source property Sha256HashFile(adjustedSourcePath) The source path is adjusted based on the manager’s working directory when set.\nMode Validation File modes are validated during resource creation:\nStrip optional 0o or 0O prefix Parse as octal number (base 8) Validate range: must be ≤ 0777 Valid Mode Examples:\nInput Parsed Value \"0644\" 0o644 \"644\" 0o644 \"0o755\" 0o755 \"0O700\" 0o700 Invalid Mode Examples:\nInput Error \"0888\" Invalid octal digit \"1777\" Exceeds maximum (setuid/setgid not supported via mode) \"rw-r--r--\" Not octal format Ownership Resolution Owner and group names are resolved to numeric UID/GID via:\nuid, gid, err := util.LookupOwnerGroup(owner, group) This uses the system’s user database (/etc/passwd, /etc/group, or equivalent):\nuser.Lookup(owner) → UID user.LookupGroup(group) → GID Error Handling:\nCondition Behavior User not found Return error: “could not lookup user” Group not found Return error: “could not lookup group” Invalid UID/GID format Return error from strconv.Atoi Working Directory Support When a manager has a working directory set (e.g., from extracted manifest), the source property path is adjusted:\nfunc (t *Type) adjustedSource(properties *model.FileResourceProperties) string { source := properties.Source if properties.Source != \"\" \u0026\u0026 t.mgr.WorkingDirectory() != \"\" { source = filepath.Join(t.mgr.WorkingDirectory(), properties.Source) } return source } This allows manifests to use relative paths for source files bundled with the manifest.\nPlatform Support The Posix provider uses Unix-specific system calls:\nOperation System Call Get file owner/group syscall.Stat_t (UID/GID from stat) Set ownership os.Chown() → chown(2) Set permissions os.Chmod() → chmod(2) The provider has separate implementations for Unix and Windows (file_unix.go, file_windows.go in internal/util), with Windows returning errors for ownership operations.\nSecurity Considerations Atomic Writes Files are written atomically via temp file + rename. This prevents:\nPartial file reads during write Corruption if process is interrupted Race conditions with concurrent readers Permission Ordering Permissions and ownership are set on the temp file before rename:\nChmod - Set permissions Write content Chown - Set ownership Rename to target This ensures the file never exists at the target path with incorrect permissions.\nPath Validation File paths must be absolute and clean (no . or .. components):\nif filepath.Clean(p.Name) != p.Name { return fmt.Errorf(\"file path must be absolute\") } Required Properties Owner, group, and mode are required properties and cannot be empty, preventing accidental creation of files with default/inherited permissions.",
    "description": "This document describes the implementation details of the Posix file provider for managing files and directories on Unix-like systems.\nProvider Selection The Posix provider is the default and only file provider. It is always available and returns priority 1 for all file resources.\nOperations Store (Create/Update File) Process:",
    "tags": [],
    "title": "Posix Provider",
    "uri": "/design/file/posix/index.html"
  },
  {
    "breadcrumb": "Introduction",
    "content": "Resources describe the desired state of your infrastructure. Each resource represents something to manage and is backed by a provider that implements platform-specific management logic.\nEvery resource has a type, a unique name, and resource-specific properties.\nCommon Properties All resources support the following common properties:\nProperty Description name Unique identifier for the resource ensure Desired state (values vary by resource type) alias Alternative name for use in subscribe, require, and logging provider Force a specific provider require List of resources (type#name or type#alias) that must succeed first health_checks Health checks to run after applying (see Monitoring) control Conditional execution rules (see below) Conditional Resource Execution Resources can be conditionally executed using a control section and expressions that should resolve to boolean values.\n​ Manifest CLI API Request package: name: zsh ensure: 5.9 control: if: lookup(\"facts.host.info.os\") == \"linux\" unless: lookup(\"facts.host.info.virtualizationSystem\") == \"docker\" ccm ensure package zsh 5.9 \\ --if \"lookup('facts.host.info.os') == 'linux'\" --unless \"lookup('facts.host.info.virtualizationSystem') == 'docker'\" { \"protocol\": \"io.choria.ccm.v1.resource.ensure.request\", \"type\": \"package\", \"properties\": { \"name\": \"zsh\", \"ensure\": \"5.9\", \"control\": { \"if\": \"lookup(\\\"facts.host.info.os\\\") == \\\"linux\\\"\", \"unless\": \"lookup(\\\"facts.host.info.virtualizationSystem\\\") == \\\"docker\\\"\" } } } Here we install zsh on all linux machines unless they are running inside a docker container.\nThe following table shows how the two conditions interact:\nif unless Resource Managed? (not set) (not set) Yes true (not set) Yes false (not set) No (not set) true No (not set) false Yes true true No true false Yes false true No false false No About Names Resources can be specified like:\n/etc/motd: ensure: present This sets name to /etc/motd, in the following paragraphs we will refer to this as name.\nArchive The archive resource downloads and extracts archives from HTTP/HTTPS URLs. It supports tar.gz, tgz, tar, and zip formats.\nNote The archive file path (name) must have the same archive type extension as the URL. For example, if the URL ends in .tar.gz, the name must also end in .tar.gz.\n​ Manifest CLI API Request - archive: - /opt/downloads/app-v1.2.3.tar.gz: url: https://releases.example.com/app/v1.2.3/app-v1.2.3.tar.gz checksum: \"a1b2c3d4e5f6...\" extract_parent: /opt/app creates: /opt/app/bin/app owner: app group: app cleanup: true ccm ensure archive /opt/downloads/app.tar.gz \\ --url https://releases.example.com/app.tar.gz \\ --extract-parent /opt/app \\ --creates /opt/app/bin/app \\ --owner root --group root { \"protocol\": \"io.choria.ccm.v1.resource.ensure.request\", \"type\": \"archive\", \"properties\": { \"name\": \"/opt/downloads/app-v1.2.3.tar.gz\", \"url\": \"https://releases.example.com/app/v1.2.3/app-v1.2.3.tar.gz\", \"checksum\": \"a1b2c3d4e5f6...\", \"extract_parent\": \"/opt/app\", \"creates\": \"/opt/app/bin/app\", \"owner\": \"app\", \"group\": \"app\", \"cleanup\": true } } This downloads the archive, extracts it to /opt/app, and removes the archive file after extraction. Future runs skip the download if /opt/app/bin/app exists.\nEnsure Values Value Description present The archive must be downloaded absent The archive file must not exist Properties Property Description name Absolute path where the archive will be saved url HTTP/HTTPS URL to download the archive from checksum Expected SHA256 checksum of the downloaded file extract_parent Directory to extract the archive contents into creates File path; if this file exists, the archive is not downloaded or extracted cleanup Remove the archive file after successful extraction (requires extract_parent and creates) owner Owner of the downloaded archive file (username) group Group of the downloaded archive file (group name) username Username for HTTP Basic Authentication password Password for HTTP Basic Authentication headers Additional HTTP headers to send with the request (map of header name to value) provider Force a specific provider (http only) Authentication The archive resource supports two authentication methods:\nBasic Authentication:\n​ Manifest CLI API Request - archive: - /opt/downloads/private-app.tar.gz: url: https://private.example.com/app.tar.gz username: deploy password: \"{{ lookup('data.deploy_password') }}\" extract_parent: /opt/app owner: root group: root ccm ensure archive /opt/downloads/private-app.tar.gz \\ --url https://private.example.com/app.tar.gz \\ --username deploy \\ --password \"{{ lookup('data.deploy_password') }}\" { \"protocol\": \"io.choria.ccm.v1.resource.ensure.request\", \"type\": \"archive\", \"properties\": { \"name\": \"/opt/downloads/private-app.tar.gz\", \"url\": \"https://private.example.com/app.tar.gz\", \"username\": \"deploy\", \"password\": \"secret\", \"extract_parent\": \"/opt/app\", \"owner\": \"root\", \"group\": \"root\" } } Custom Headers:\n​ Manifest CLI API Request - archive: - /opt/downloads/app.tar.gz: url: https://api.example.com/releases/app.tar.gz headers: Authorization: \"Bearer {{ lookup('data.api_token') }}\" X-Custom-Header: custom-value extract_parent: /opt/app owner: root group: root ccm ensure archive /opt/downloads/app.tar.gz \\ --url https://api.example.com/releases/app.tar.gz \\ --headers \"Authorization:{{ lookup('data.api_token') }}\" { \"protocol\": \"io.choria.ccm.v1.resource.ensure.request\", \"type\": \"archive\", \"properties\": { \"name\": \"/opt/downloads/app.tar.gz\", \"url\": \"https://api.example.com/releases/app.tar.gz\", \"headers\": { \"Authorization\": \"Bearer mytoken\", \"X-Custom-Header\": \"custom-value\" }, \"extract_parent\": \"/opt/app\", \"owner\": \"root\", \"group\": \"root\" } } Idempotency The archive resource is idempotent through multiple mechanisms:\nChecksum verification: If a checksum is provided and the existing file matches, no download occurs. Creates file: If creates is specified and that file exists, neither download nor extraction occurs. File existence: If the archive file exists with matching checksum and owner/group, no changes are made. For best idempotency, always specify either checksum or creates (or both).\nCleanup Behavior When cleanup: true is set:\nThe archive file is deleted after successful extraction The extract_parent property is required The creates property is required to track extraction state across runs Supported Archive Formats Extension Extraction Tool .tar.gz, .tgz tar -xzf .tar tar -xf .zip unzip Note The extraction tools (tar, unzip) must be available in the system PATH.\nExec The exec resource executes commands to bring the system into the desired state. It is idempotent when used with the creates property or refreshonly mode.\nWarning Specify commands with their full path, or use the path property to set the search path.\n​ Manifest CLI API Request - exec: - /usr/bin/touch /tmp/hello: creates: /tmp/hello timeout: 30s cwd: /tmp Alternatively for long commands or to improve UX for referencing execs in require or subscribe:\n- exec: - touch_hello: command: /usr/bin/touch /tmp/hello creates: /tmp/hello timeout: 30s cwd: /tmp ccm ensure exec \"/usr/bin/touch /tmp/hello\" --creates /tmp/hello --timeout 30s { \"protocol\": \"io.choria.ccm.v1.resource.ensure.request\", \"type\": \"exec\", \"properties\": { \"name\": \"/usr/bin/touch /tmp/hello\", \"creates\": \"/tmp/hello\", \"timeout\": \"30s\", \"cwd\": \"/tmp\" } } The command runs only if /tmp/hello does not exist.\nProviders The exec resource supports two providers:\nProvider Description posix Default. Executes commands directly without a shell. Arguments are parsed and passed to the executable. shell Executes commands via /bin/sh -c \"...\". Use this for shell features like pipes, redirections, and builtins. The posix provider is the default and is suitable for most commands. Use the shell provider when you need shell features:\n- exec: - cleanup-logs: command: find /var/log -name '*.log' -mtime +30 -delete \u0026\u0026 echo \"Done\" provider: shell - check-service: command: systemctl is-active httpd || systemctl start httpd provider: shell - process-data: command: cat /tmp/input.txt | grep -v '^#' | sort | uniq \u003e /tmp/output.txt provider: shell Note The shell provider passes the entire command string to /bin/sh -c, so shell quoting rules apply. The posix provider parses arguments using shell-like quoting but does not invoke a shell.\nProperties Property Description name The command to execute (used as the resource identifier) command Alternative command to run instead of name cwd Working directory for command execution environment (array) Environment variables in KEY=VALUE format path Search path for executables as a colon-separated list (e.g., /usr/bin:/bin) returns (array) Exit codes indicating success (default: [0]) timeout Maximum execution time (e.g., 30s, 5m); command is killed if exceeded creates File path; if this file exists, the command does not run refreshonly (boolean) Only run when notified by a subscribed resource subscribe (array) Resources to subscribe to for refresh notifications (type#name or type#alias) logoutput (boolean) Log the command output provider Force a specific provider (posix or shell) File The file resource manages files and directories, including their content, ownership, and permissions.\nWarning Use absolute file paths and primary group names.\n​ Manifest CLI API Request - file: - /etc/motd: ensure: present content: | Managed by CCM {{ now() }} owner: root group: root mode: \"0644\" ccm ensure file /etc/motd --source /tmp/ccm/motd --owner root --group root --mode 0644 { \"protocol\": \"io.choria.ccm.v1.resource.ensure.request\", \"type\": \"file\", \"properties\": { \"name\": \"/etc/motd\", \"ensure\": \"present\", \"content\": \"Managed by CCM\\n\", \"owner\": \"root\", \"group\": \"root\", \"mode\": \"0644\" } } This copies the contents of /tmp/ccm/motd to /etc/motd verbatim and sets ownership.\nUse --content or --content-file to parse content through the template engine before writing.\nEnsure Values Value Description present The file must exist absent The file must not exist directory The path must be a directory Properties Property Description name Absolute path to the file ensure Desired state (present, absent, directory) content File contents, parsed through the template engine source Copy contents from another local file owner File owner (username) group File group (group name) mode File permissions in octal notation (e.g., \"0644\") provider Force a specific provider (posix only) Package The package resource manages system packages. Specify whether the package should be present, absent, at the latest version, or at a specific version.\nWarning Use real package names, not virtual names, aliases, or group names.\n​ Manifest CLI API Request - package: - zsh: ensure: \"5.9\" ccm ensure package zsh 5.9 { \"protocol\": \"io.choria.ccm.v1.resource.ensure.request\", \"type\": \"package\", \"properties\": { \"name\": \"zsh\", \"ensure\": \"5.9\" } } Ensure Values Value Description present The package must be installed latest The package must be installed at latest version absent The package must not be installed \u003cversion\u003e The package must be installed at this version Properties Property Description name Package name ensure Desired state or version provider Force a specific provider (dnf, apt) Provider Notes APT (Debian/Ubuntu) The APT provider preserves existing configuration files during package installation and upgrades. When a package is upgraded and the maintainer has provided a new version of a configuration file, the existing file is kept (--force-confold behavior).\nPackages in a partially installed or config-files state (removed but configuration remains) are treated as absent. Reinstalling such packages will preserve the existing configuration files.\nNote The provider will not run apt update before installing a package. Use an exec resource to update the package index if necessary.\nThe provider runs non-interactively and suppresses prompts from apt-listbugs and apt-listchanges.\nService The service resource manages system services. Services have two independent properties: whether they are running and whether they are enabled to start at boot.\nWarning Use real service names, not virtual names or aliases.\nServices can subscribe to other resources and restart when those resources change.\n​ Manifest CLI API Request - service: - httpd: ensure: running enable: true subscribe: - package#httpd ccm ensure service httpd running --enable --subscribe package#httpd { \"protocol\": \"io.choria.ccm.v1.resource.ensure.request\", \"type\": \"service\", \"properties\": { \"name\": \"httpd\", \"ensure\": \"running\", \"enable\": true, \"subscribe\": [\"package#httpd\"] } } Ensure Values Value Description running The service must be running stopped The service must be stopped If ensure is not specified, it defaults to running.\nProperties Property Description name Service name ensure Desired state (running or stopped; default: running) enable (boolean) Enable the service to start at boot subscribe (array) Resources to watch; restart the service when they change (type#name or type#alias) provider Force a specific provider (systemd only)",
    "description": "Resources describe the desired state of your infrastructure. Each resource represents something to manage and is backed by a provider that implements platform-specific management logic.\nEvery resource has a type, a unique name, and resource-specific properties.\nCommon Properties All resources support the following common properties:\nProperty Description name Unique identifier for the resource ensure Desired state (values vary by resource type) alias Alternative name for use in subscribe, require, and logging provider Force a specific provider require List of resources (type#name or type#alias) that must succeed first health_checks Health checks to run after applying (see Monitoring) control Conditional execution rules (see below) Conditional Resource Execution Resources can be conditionally executed using a control section and expressions that should resolve to boolean values.",
    "tags": [],
    "title": "Resources",
    "uri": "/resources/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Design Documents \u003e Service Type",
    "content": "This document describes the implementation details of the Systemd service provider for managing system services via systemctl.\nProvider Selection The Systemd provider is selected when systemctl is found in the system PATH. The provider checks for the executable using util.ExecutableInPath(\"systemctl\").\nAvailability Check:\nSearches PATH for systemctl Returns priority 1 if found Returns unavailable if not found Concurrency A global service lock (model.ServiceGlobalLock) is held during all systemctl command executions to prevent concurrent systemd operations within the same process. This prevents race conditions when multiple service resources are managed simultaneously.\nfunc (p *Provider) execute(ctx context.Context, cmd string, args ...string) (...) { model.ServiceGlobalLock.Lock() defer model.ServiceGlobalLock.Unlock() return p.runner.Execute(ctx, cmd, args...) } Daemon Reload The provider performs a systemctl daemon-reload once per provider instance before any service operations. This ensures systemd picks up any unit file changes made by other resources (e.g., file resources managing unit files).\nfunc (p *Provider) maybeReload(ctx context.Context) error { p.mu.Lock() defer p.mu.Unlock() if p.didReload { return nil } _, _, _, err := p.execute(ctx, \"systemctl\", \"daemon-reload\") return err } The reload is performed only once, tracked by the didReload flag.\nOperations Status Commands:\nsystemctl is-active --system \u003cservice\u003e systemctl is-enabled --system \u003cservice\u003e Active State Detection:\nis-active Output Interpreted As active Running inactive Stopped failed Stopped activating Stopped Other Error Enabled State Detection:\nis-enabled Output Interpreted As enabled Enabled enabled-runtime Enabled alias Enabled static Enabled indirect Enabled generated Enabled transient Enabled linked Disabled linked-runtime Disabled masked Disabled masked-runtime Disabled disabled Disabled not-found Error: service not found Returned State:\nField Value Ensure running or stopped based on is-active Metadata.Enabled Boolean from is-enabled Metadata.Running Boolean from is-active Metadata.Provider “systemd” Start Command:\nsystemctl start --system \u003cservice\u003e Called when ensure: running and service is currently stopped.\nStop Command:\nsystemctl stop --system \u003cservice\u003e Called when ensure: stopped and service is currently running.\nRestart Command:\nsystemctl restart --system \u003cservice\u003e Called when a subscribed resource has changed and the service should be refreshed.\nEnable Command:\nsystemctl enable --system \u003cservice\u003e Called when enable: true and service is currently disabled.\nDisable Command:\nsystemctl disable --system \u003cservice\u003e Called when enable: false and service is currently enabled.\nCommand Flags All commands use the --system flag to explicitly target system-level units (as opposed to user-level units managed with --user).\nDecision Flow Ensure State (Running/Stopped) ┌─────────────────────────────────────────┐ │ Subscribe triggered? │ │ (subscribed resource changed) │ └─────────────┬───────────────┬───────────┘ │ Yes │ No │ │ │ ▼ │ ┌───────────────────┐ │ │ Ensure = stopped? │ │ └─────────┬─────────┘ │ Yes │ No │ ▼ ▼ │ ┌─────────┐ ┌───────────────────┐ │ │ Running?│ │ Ensure = running? │ │ └────┬────┘ └─────────┬─────────┘ │ Yes │ No Yes │ No │ ▼ ▼ │ ┌────────┐ ┌─────────┐ │ │ Stop │ │ Running?│ │ └────────┘ └────┬────┘ │ No │ Yes │ ▼ │ ┌────────┐ │ │ Start │ │ └────────┘ │ ▼ ┌───────────────────────────────┐ │ Ensure = running? │ │ (only restart running services)│ └───────────────┬───────────────┘ Yes │ No ▼ ┌─────────────┐ │ Restart │ └─────────────┘ Subscribe Behavior Notes:\nRestart only occurs if ensure: running If service is stopped and ensure: running, it starts instead of restarting Subscribe is ignored if ensure: stopped Enable State Enable/disable is processed independently after ensure state:\n┌─────────────────────────────────────────┐ │ Enable property set? │ └─────────────┬───────────────┬───────────┘ │ Yes │ No (nil) │ │ │ ▼ │ ┌───────────────┐ │ │ No change │ │ └───────────────┘ ▼ ┌───────────────────────────────┐ │ Enable = true? │ └───────────────┬───────────────┘ Yes │ No ▼ ┌───────────────────────────────┐ │ Currently enabled? │ └───────────────┬───────────────┘ No │ Yes ▼ ┌─────────────┐ │ Enable │ └─────────────┘ (Similar flow for disable when enable=false) Idempotency The service resource checks current state before making changes:\nDesired State Current State Action running running None running stopped Start stopped stopped None stopped running Stop enable: true enabled None enable: true disabled Enable enable: false enabled Disable enable: false disabled None enable: nil any None Service Name Validation Service names are validated to prevent shell injection:\nDangerous Characters Check:\nif dangerousCharsRegex.MatchString(p.Name) { return fmt.Errorf(\"service name contains dangerous characters: %q\", p.Name) } Allowed Characters:\nAlphanumeric (a-z, A-Z, 0-9) Period (.) Underscore (_) Plus (+) Colon (:) Tilde (~) Hyphen (-) Examples:\nName Valid httpd Yes nginx.service Yes my-app_v2 Yes app@instance No (@ not allowed) app; rm -rf / No (shell metacharacters) Subscribe and Refresh Services can subscribe to other resources and restart when they change:\n- file: - /etc/myapp/config.yaml: ensure: present content: \"...\" owner: root group: root mode: \"0644\" - service: - myapp: ensure: running enable: true subscribe: - file#/etc/myapp/config.yaml Behavior:\nWhen the file resource changes, the service is restarted Restart only occurs if ensure: running If service was stopped and should be running, it starts (not restarts) Error Handling Condition Behavior systemctl not in PATH Provider unavailable Service not found Error from is-enabled: “service not found” Unknown is-active output Error: “invalid systemctl is-active output” Unknown is-enabled output Error: “invalid systemctl is-enabled output” Command execution failure Error propagated from runner Platform Support The Systemd provider requires:\nLinux with systemd as init system systemctl command available in PATH It does not support:\nNon-systemd init systems (SysVinit, Upstart, OpenRC) User-level units (uses --system flag) Windows, macOS, or BSD systems",
    "description": "This document describes the implementation details of the Systemd service provider for managing system services via systemctl.\nProvider Selection The Systemd provider is selected when systemctl is found in the system PATH. The provider checks for the executable using util.ExecutableInPath(\"systemctl\").\nAvailability Check:\nSearches PATH for systemctl Returns priority 1 if found Returns unavailable if not found Concurrency A global service lock (model.ServiceGlobalLock) is held during all systemctl command executions to prevent concurrent systemd operations within the same process. This prevents race conditions when multiple service resources are managed simultaneously.",
    "tags": [],
    "title": "Systemd Provider",
    "uri": "/design/service/systemd/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Shell Usage",
    "content": "CCM supports extending the CLI with custom commands using App Builder. This allows you to create organization-specific workflows that integrate with the ccm command.\nPlugin Locations CCM searches for plugins in two directories:\nLocation Purpose /etc/choria/ccm/plugins/ System-wide plugins $XDG_CONFIG_HOME/choria/ccm/plugins/ User plugins (typically ~/.config/choria/ccm/plugins/) Plugins in the user directory override system plugins with the same name.\nPlugin File Format Plugin files must be named \u003ccommand\u003e-plugin.yaml. The filename determines the command name:\ndeploy-plugin.yaml → ccm deploy backup-plugin.yaml → ccm backup myapp-plugin.yaml → ccm myapp Basic Plugin Structure Plugins use App Builder’s YAML definition format. Here’s a minimal example:\n# deploy-plugin.yaml name: deploy description: Deploy application configuration commands: - name: web description: Deploy web server configuration type: exec command: | ccm apply /etc/ccm/manifests/webserver.yaml This creates ccm deploy web which applies a manifest.\nPassing Data to Manifests Plugins can pass data to manifests through environment variables or facts. Both are accessible in manifest templates.\nUsing Environment Variables Environment variables set in the plugin are available in manifests via {{ lookup(\"env.VAR_NAME\") }}:\n# deploy-plugin.yaml name: deploy description: Deploy with environment commands: - name: production description: Deploy to production type: exec environment: - \"DEPLOY_ENV=production\" - \"LOG_LEVEL=warn\" command: | ccm apply /etc/ccm/manifests/app.yaml In the manifest:\nresources: - type: file name: /etc/app/config.yaml content: | environment: {{ lookup(\"env.DEPLOY_ENV\") }} log_level: {{ lookup(\"env.LOG_LEVEL\") }} Using Facts Pass additional facts using the --fact flag. Facts are available via {{ lookup(\"facts.KEY\") }}:\n# deploy-plugin.yaml name: deploy description: Deploy with custom facts commands: - name: app description: Deploy application type: exec arguments: - name: version description: Application version to deploy required: true command: | ccm apply /etc/ccm/manifests/app.yaml --fact app_version={{ .Arguments.version }} In the manifest:\nresources: - type: package name: myapp ensure: present version: \"{{ lookup('facts.app_version') }}\" Further Reading For complete App Builder documentation including all command types, templating features, and advanced options, see the App Builder documentation.\nSince version 0.13.0 of App Builder it has a transform and a command that can invoke CCM Manifests, this combines well with flags, arguments and form wizards to create custom UI’s that manage your infrastructure.",
    "description": "CCM supports extending the CLI with custom commands using App Builder. This allows you to create organization-specific workflows that integrate with the ccm command.\nPlugin Locations CCM searches for plugins in two directories:\nLocation Purpose /etc/choria/ccm/plugins/ System-wide plugins $XDG_CONFIG_HOME/choria/ccm/plugins/ User plugins (typically ~/.config/choria/ccm/plugins/) Plugins in the user directory override system plugins with the same name.\nPlugin File Format Plugin files must be named \u003ccommand\u003e-plugin.yaml. The filename determines the command name:",
    "tags": [],
    "title": "CLI Plugins",
    "uri": "/cli/plugins/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Design Documents \u003e Package Type",
    "content": "This document describes the implementation details of the DNF package provider for RHEL/Fedora-based systems.\nConcurrency A global package lock (model.PackageGlobalLock) is held during all command executions to prevent concurrent dnf/rpm operations within the same process. This prevents lock contention on the RPM database.\nOperations Status Check Command:\nrpm -q \u003cpackage\u003e --queryformat '%{NAME} %|EPOCH?{%{EPOCH}}:{0}| %{VERSION} %{RELEASE} %{ARCH}' Query Format (NEVRA): The query format extracts the full NEVRA (Name, Epoch, Version, Release, Architecture):\nField Description %{NAME} Package name %|EPOCH?{%{EPOCH}}:{0}| Epoch (0 if not set) %{VERSION} Upstream version %{RELEASE} Release/build number %{ARCH} Architecture (x86_64, noarch, etc.) Example output:\nzsh 0 5.8 9.el9 x86_64 Behavior:\nExit code 0 → Package is present, parses NEVRA components Exit code non-zero → Package is absent Returned Version Format: The version returned combines VERSION and RELEASE: 5.8-9.el9\nThe epoch and release are stored separately in the Extended metadata.\nInstall Ensure Present or Latest:\ndnf install -y \u003cpackage\u003e Specific Version:\ndnf install -y \u003cpackage\u003e-\u003cversion\u003e Flags:\nFlag Purpose -y Assume yes to all prompts Note: DNF uses - (hyphen) to separate package name from version, unlike APT which uses =.\nUpgrade Delegates to Install(). DNF’s install command handles upgrades automatically when a newer version is available or specified.\nDowngrade Command:\ndnf downgrade -y \u003cpackage\u003e-\u003cversion\u003e Note: Unlike upgrade, downgrade uses a dedicated DNF command rather than delegating to install.\nUninstall Command:\ndnf remove -y \u003cpackage\u003e Version Format RPM versions follow the EVR (Epoch:Version-Release) format:\n[epoch:]version-release Component Required Description epoch No Integer, default 0. Higher epoch always wins. version Yes Upstream version number release Yes Distribution-specific release/build number Examples:\n5.8-9.el9 → epoch=0, version=5.8, release=9.el9 1:2.0-3.fc39 → epoch=1, version=2.0, release=3.fc39 0:1.0.0-1.el9 → epoch=0 (explicit), version=1.0.0, release=1.el9 Version Comparison Version comparison uses a generic algorithm ported from Puppet, implemented in internal/util.VersionCmp().\nAlgorithm The version string is tokenized into segments by splitting on -, ., digits, and non-digit sequences. Segments are compared left-to-right:\nHyphens (-) - A hyphen loses to any other character Dots (.) - A dot loses to any non-hyphen character Digit sequences - Compared numerically, except: Leading zeros trigger lexical comparison (01 vs 1 compared as strings) Non-digit sequences - Compared lexically (case-insensitive) If all segments match, falls back to whole-string comparison.\nTrailing Zero Normalization When ignoreTrailingZeroes is enabled, trailing .0 segments before the first - are removed:\n1.0.0-rc1 → 1-rc1 2.0.0 → 2 This allows 1.0.0 to equal 1.0 when the flag is set.\nComparison Examples A B Result Reason 1.0 2.0 A \u003c B Numeric: 1 \u003c 2 1.10 1.9 A \u003e B Numeric: 10 \u003e 9 1.0 1.0.1 A \u003c B A exhausted first 1.0-1 1.0-2 A \u003c B Release comparison 1.0a 1.0b A \u003c B Lexical: a \u003c b 01 1 A \u003c B Leading zero: lexical comparison 1.0.0 1.0 A \u003e B Without normalization 1.0.0 1.0 A = B With ignoreTrailingZeroes=true Implementation The version comparison is implemented in internal/util/util.go and provides:\nVersionCmp(a, b, ignoreTrailingZeroes) - Compare two version strings Returns -1 (a \u003c b), 0 (a == b), or 1 (a \u003e b)",
    "description": "This document describes the implementation details of the DNF package provider for RHEL/Fedora-based systems.\nConcurrency A global package lock (model.PackageGlobalLock) is held during all command executions to prevent concurrent dnf/rpm operations within the same process. This prevents lock contention on the RPM database.\nOperations Status Check Command:",
    "tags": [],
    "title": "DNF Provider",
    "uri": "/design/package/dnf/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Design Documents",
    "content": "This document describes the design of the exec resource type for executing commands.\nOverview The exec resource executes commands with idempotency controls:\nCreates: Skip execution if a file exists Refresh Only: Only execute when triggered by a subscribed resource Exit Codes: Validate success via configurable return codes Provider Interface Exec providers must implement the ExecProvider interface:\ntype ExecProvider interface { model.Provider Execute(ctx context.Context, properties *model.ExecResourceProperties, log model.Logger) (int, error) Status(ctx context.Context, properties *model.ExecResourceProperties) (*model.ExecState, error) } Method Responsibilities Method Responsibility Status Check if creates file exists, return current state Execute Run the command, return exit code Status Response The Status method returns an ExecState containing:\ntype ExecState struct { CommonResourceState ExitCode *int // Exit code from last execution (nil if not run) CreatesSatisfied bool // Whether creates file exists } The Ensure field in CommonResourceState is set to:\npresent if the creates file exists absent if the creates file does not exist (or not specified) Available Providers Provider Execution Method Documentation posix Direct exec (no shell) Posix shell Via /bin/sh -c Shell Properties Property Type Description command string Command to run (defaults to name if not set) cwd string Working directory for command execution environment []string Additional environment variables (KEY=value) path string Search path for executables (colon-separated) returns []int Acceptable exit codes (default: [0]) timeout string Maximum execution time (e.g., 30s, 5m) creates string File path; skip execution if exists refresh_only bool Only execute via subscribe refresh subscribe []string Resources to watch for changes (type#name) logoutput bool Log command output Apply Logic ┌─────────────────────────────────────────┐ │ Get current state via Status() │ └─────────────────┬───────────────────────┘ │ ▼ ┌─────────────────────────────────────────┐ │ Check for subscribe refresh │ └─────────────────┬───────────────────────┘ │ ┌─────────────┴─────────────┐ │ Subscribed resource │ │ changed? │ └─────────────┬─────────────┘ Yes │ No ▼ │ ┌───────────┐ │ │ Execute │ │ └───────────┘ │ ▼ ┌─────────────────────────┐ │ Is desired state met? │ │ (creates file exists OR │ │ refresh_only is true) │ └─────────────┬───────────┘ Yes │ No ▼ │ ┌───────────┐ │ │ Skip │ │ └───────────┘ │ ▼ ┌─────────────────────────┐ │ Is refresh_only = true? │ └─────────────┬───────────┘ Yes │ No ▼ │ ┌───────────┐ │ │ Skip │ │ └───────────┘ │ ▼ ┌───────────┐ │ Execute │ └───────────┘ Idempotency The exec resource provides idempotency through two mechanisms:\nCreates Property The creates property specifies a file that indicates successful prior execution:\n- exec: - extract-archive: command: tar xzf /tmp/app.tar.gz -C /opt creates: /opt/app/bin/app Behavior:\nIf /opt/app/bin/app exists, skip execution Useful for one-time setup commands Provider checks file existence via Status() Refresh Only Property The refresh_only property limits execution to subscribe refreshes:\n- exec: - reload-nginx: command: systemctl reload nginx refresh_only: true subscribe: - file#/etc/nginx/nginx.conf Behavior:\nCommand only runs when subscribed resource changes Without a subscribe trigger, command is skipped Useful for reload/restart commands Decision Table Condition Action Subscribe triggered Execute creates file exists Skip refresh_only: true + no trigger Skip refresh_only: false + no creates Execute Subscribe Behavior Exec resources can subscribe to other resources and execute when they change:\n- file: - /etc/app/config.yaml: ensure: present content: \"...\" - exec: - reload-app: command: systemctl reload app refresh_only: true subscribe: - file#/etc/app/config.yaml Subscribe takes precedence over other idempotency checks - if a subscribed resource changed, the command executes regardless of creates file existence.\nExit Code Validation By default, exit code 0 indicates success. The returns property customizes acceptable codes:\n- exec: - check-status: command: /usr/local/bin/check-health returns: - 0 - 1 - 2 Behavior:\nCommand succeeds if exit code is in returns list Command fails if exit code is not in returns list Used for desired state validation after execution Noop Mode In noop mode, the exec type:\nQueries current state normally (checks creates file) Evaluates subscribe triggers Logs what actions would be taken Sets appropriate NoopMessage: “Would have executed” “Would have executed via subscribe” Reports Changed: true if execution would occur Does not call provider Execute method Desired State Validation After execution (in non-noop mode), the type verifies success:\nfunc (t *Type) isDesiredState(properties, status) bool { // Creates file check takes precedence if properties.Creates != \"\" \u0026\u0026 status.CreatesSatisfied { return true } // Refresh-only without execution is stable if status.ExitCode == nil \u0026\u0026 properties.RefreshOnly { return true } // Check exit code against acceptable returns returns := []int{0} if len(properties.Returns) \u003e 0 { returns = properties.Returns } if status.ExitCode != nil { return slices.Contains(returns, *status.ExitCode) } return false } If the exit code is not in the acceptable returns list, an ErrDesiredStateFailed error is returned.\nCommand vs Name The command property is optional. If not specified, the name is used as the command:\n# These are equivalent: - exec: - /usr/bin/myapp --config /etc/myapp.conf: - exec: - run-myapp: command: /usr/bin/myapp --config /etc/myapp.conf Using a descriptive name with explicit command is recommended for clarity.\nEnvironment and Path Commands can be configured with custom environment:\n- exec: - build-app: command: make build cwd: /opt/app environment: - CC=gcc - CFLAGS=-O2 path: /usr/local/bin:/usr/bin:/bin Environment:\nAdded to the command’s environment Format: KEY=value Does not replace existing environment Path:\nSets the PATH for executable lookup Must be absolute directories Colon-separated list",
    "description": "This document describes the design of the exec resource type for executing commands.\nOverview The exec resource executes commands with idempotency controls:\nCreates: Skip execution if a file exists Refresh Only: Only execute when triggered by a subscribed resource Exit Codes: Validate success via configurable return codes Provider Interface Exec providers must implement the ExecProvider interface:",
    "tags": [],
    "title": "Exec Type",
    "uri": "/design/exec/index.html"
  },
  {
    "breadcrumb": "Introduction",
    "content": "The Choria Hierarchical Data Resolver is a small data resolver inspired by Hiera. It evaluates a YAML or JSON document alongside a set of facts to produce a final data map.\nThe resolver supports first and deep merge strategies and relies on expression-based string interpolation for hierarchy entries. It is optimized for single files that hold both hierarchy and data, rather than the multi-file approach common in Hiera.\nKey features:\nLookup expressions based on the Expr Language Type-preserving lookups (returns typed data, not just strings) Command-line tool with built-in system facts Go library for embedding Usage Here’s an annotated example:\nhierarchy: # Lookup and override order - facts are resolved in expressions # Use GJSON path syntax for nested facts: {{ lookup('facts.host.info.hostname') }} order: - env:{{ lookup('facts.env') }} - role:{{ lookup('facts.role') }} - host:{{ lookup('facts.hostname') }} merge: deep # \"deep\" merges all matches; \"first\" stops at first match # Base data - hierarchy results are merged into this data: log_level: INFO packages: - ca-certificates web: listen_port: 80 tls: false # Override sections keyed by hierarchy order entries overrides: env:prod: log_level: WARN role:web: packages: - nginx web: listen_port: 443 tls: true host:web01: log_level: TRACE The templating here is identical to that in the Data documentation, except only the lookup() function is available (no file access functions).\nDefault Hierarchy If no hierarchy section is provided, the resolver uses a default hierarchy of [\"default\"].\nCLI Example The ccm hiera command resolves hierarchy files with facts. It is designed to be a generally usable tool, with flexible options for providing facts.\nGiven the input file data.json:\n{ \"hierarchy\": { \"order\": [ \"fqdn:{{ lookup('facts.fqdn') }}\" ] }, \"data\": { \"test\": \"value\" }, \"overrides\": { \"fqdn:my.fqdn.com\": { \"test\": \"override\" } } } Resolve with facts provided on the command line:\n$ ccm hiera parse data.json fqdn=my.fqdn.com { \"test\": \"override\" } $ ccm hiera parse data.json fqdn=other.fqdn.com { \"test\": \"value\" } Output formats:\n# YAML output $ ccm hiera parse data.json fqdn=other.fqdn.com --yaml test: value # Environment variable output $ ccm hiera parse data.json fqdn=other.fqdn.com --env HIERA_TEST=value Fact Sources Facts can come from multiple sources, which are merged together:\nSystem facts (-S or --system-facts):\n# View system facts $ ccm hiera facts -S # Resolve using system facts $ ccm hiera parse data.json -S Environment variables as facts (-E or --env-facts):\nccm hiera parse data.json -E Facts file (--facts FILE):\nccm hiera parse data.json --facts facts.yaml Command-line facts (key=value pairs):\nccm hiera parse data.json env=prod role=web All fact sources can be combined. Command-line facts take highest precedence.\nData in NATS NATS is a lightweight messaging system that supports Key-Value stores. Hierarchy data can be stored in NATS and used with ccm ensure and ccm hiera commands.\nTo use NATS as a hierarchy store, configure a NATS context for authentication:\nnats context add ccm --server nats.example.org --user ccm --password s3cret \\ --description \"CCM Configuration Store\" Create a KV store and add your hierarchy data:\n$ nats kv add CCM --replicas 3 --context ccm $ nats kv put CCM data \"$(cat hiera.yaml)\" Resolve the hierarchy using the KV store:\nccm hiera parse kv://CCM/data --context ccm -S Data on Web Servers Hierarchy data can also be stored on a web server and fetched via HTTP or HTTPS.\nccm hiera parse https://example.net/site.yaml -S HTTP Basic Auth is supported via URL credentials:\nccm hiera parse https://user:pass@example.net/site.yaml -S",
    "description": "The Choria Hierarchical Data Resolver is a small data resolver inspired by Hiera. It evaluates a YAML or JSON document alongside a set of facts to produce a final data map.\nThe resolver supports first and deep merge strategies and relies on expression-based string interpolation for hierarchy entries. It is optimized for single files that hold both hierarchy and data, rather than the multi-file approach common in Hiera.\nKey features:",
    "tags": [],
    "title": "Hierarchical Data",
    "uri": "/hiera/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Design Documents \u003e Exec Type",
    "content": "This document describes the implementation details of the Shell exec provider for executing commands via /bin/sh.\nProvider Selection The Shell provider is selected when provider: shell is explicitly specified in the resource properties. It has a lower priority (99) than the Posix provider (1), so it is never automatically selected.\nAvailability: The provider checks for the existence of /bin/sh via util.FileExists(). If /bin/sh does not exist, the provider is not available.\nComparison with Posix Provider Feature Shell Posix Shell invocation Yes (/bin/sh -c) No Pipes (|) Supported Not supported Redirections (\u003e, \u003c, \u003e\u003e) Supported Not supported Shell builtins (cd, export, source) Supported Not supported Glob expansion (*.txt, ?) Supported Not supported Command substitution ($(...), `...`) Supported Not supported Variable expansion ($VAR, ${VAR}) Supported Not supported Logical operators (\u0026\u0026, ||) Supported Not supported Argument parsing Passed as single string shellquote.Split() Security Shell injection possible Lower attack surface When to use Shell:\nCommands with pipes: cat file.txt | grep pattern | sort Commands with redirections: echo \"data\" \u003e /tmp/file Commands with shell builtins: cd /tmp \u0026\u0026 pwd Commands with variable expansion: echo $HOME Complex one-liners with logical operators When to use Posix (default):\nSimple commands with arguments When shell features are not needed For better security (no shell injection risk) Operations Execute Process:\nDetermine command source (Command property or Name if Command is empty) Validate command is not empty Execute via CommandRunner.ExecuteWithOptions() with /bin/sh -c \"\u003ccommand\u003e\" Optionally log output line-by-line if LogOutput is enabled Execution Method:\nThe entire command string is passed to the shell as a single argument:\n/bin/sh -c \"\u003centire command string\u003e\" This allows the shell to interpret all shell syntax, including:\nPipes and redirections Variable expansion Glob patterns Command substitution Logical operators Execution Options:\nOption Value Description Command /bin/sh Shell executable path Args [\"-c\", \"\u003ccommand\u003e\"] Shell flag and command string Cwd properties.Cwd Working directory Environment properties.Environment Additional env vars (KEY=VALUE format) Path properties.Path Search path for executables Timeout properties.ParsedTimeout Maximum execution time Output Logging:\nWhen LogOutput: true is set and a user logger is provided:\nscanner := bufio.NewScanner(bytes.NewReader(stdout)) for scanner.Scan() { log.Info(scanner.Text()) } Each line of stdout is logged as a separate Info message.\nError Handling:\nCondition Behavior Empty command string Return error: “no command to execute” Runner not configured Return error: “no command runner configured” Shell not found Provider not available (checked at selection time) Command execution fails Return error from runner Non-zero exit code Return exit code (not an error by itself) Status Process:\nCreate state with EnsurePresent (exec resources are always “present”) Check if Creates file exists via util.FileExists() Set CreatesSatisfied accordingly State Fields:\nField Value Protocol io.choria.ccm.v1.resource.exec.state ResourceType exec Name Resource name Ensure present (always) CreatesSatisfied true if Creates file exists Use Cases Pipes and Filters - exec: - filter-logs: command: cat /var/log/app.log | grep ERROR | tail -100 \u003e /tmp/errors.txt provider: shell creates: /tmp/errors.txt Conditional Execution - exec: - ensure-running: command: pgrep myapp || /opt/myapp/bin/start provider: shell Complex Scripts - exec: - deploy-app: command: | cd /opt/app \u0026\u0026 git pull origin main \u0026\u0026 npm install \u0026\u0026 npm run build \u0026\u0026 systemctl restart app provider: shell timeout: 5m Variable Expansion - exec: - backup-home: command: tar -czf /backup/home-$(date +%Y%m%d).tar.gz $HOME provider: shell Idempotency The shell provider uses the same idempotency mechanisms as the posix provider:\nCreates File If creates is specified and the file exists, the command does not run:\n- exec: - extract-archive: command: cd /opt \u0026\u0026 tar -xzf /tmp/app.tar.gz provider: shell creates: /opt/app/bin/app RefreshOnly Mode When refreshonly: true, the command only runs when triggered by a subscribed resource:\n- exec: - reload-nginx: command: nginx -t \u0026\u0026 systemctl reload nginx provider: shell refreshonly: true subscribe: - file#/etc/nginx/nginx.conf Exit Code Validation The returns property specifies acceptable exit codes (default: [0]):\n- exec: - check-service: command: systemctl is-active myapp || true provider: shell returns: [0] Security Considerations Shell Injection Risk The shell provider passes the command string directly to /bin/sh, making it vulnerable to shell injection if user input is incorporated:\n# DANGEROUS if filename comes from untrusted input - exec: - process-file: command: cat {{ user_provided_filename }} | process provider: shell Mitigations:\nValidate and sanitize any templated values Use the posix provider when shell features aren’t needed Prefer explicit file paths over user-provided values Environment Variable Exposure Shell commands can access environment variables, including sensitive ones:\n# $SECRET_KEY will be expanded by the shell - exec: - use-secret: command: myapp --key=$SECRET_KEY provider: shell Consider using the environment property to explicitly pass required variables rather than relying on inherited environment.\nCommand Logging The full command string (including any expanded variables) may appear in logs. Avoid embedding secrets directly in commands:\n# BAD - password visible in logs - exec: - bad-example: command: mysql -p'secret123' -e 'SELECT 1' provider: shell # BETTER - use environment variable - exec: - better-example: command: mysql -p\"$MYSQL_PWD\" -e 'SELECT 1' provider: shell environment: - MYSQL_PWD={{ lookup('data.mysql_password') }} Platform Support The shell provider requires /bin/sh to be available. This is standard on:\nLinux distributions macOS BSD variants Most Unix-like systems On Windows, the provider will not be available unless /bin/sh exists (e.g., via WSL or Cygwin).\nShell Compatibility The provider uses /bin/sh, which is typically:\nLinux: Often a symlink to bash, dash, or another POSIX-compliant shell macOS: /bin/sh is bash (older) or zsh (newer) in POSIX mode BSD: Usually ash or similar For maximum portability, use POSIX shell syntax and avoid bash-specific features like:\nArrays (arr=(1 2 3)) [[ conditionals (use [ instead) source (use . instead) Process substitution (\u003c(command))",
    "description": "This document describes the implementation details of the Shell exec provider for executing commands via /bin/sh.\nProvider Selection The Shell provider is selected when provider: shell is explicitly specified in the resource properties. It has a lower priority (99) than the Posix provider (1), so it is never automatically selected.\nAvailability: The provider checks for the existence of /bin/sh via util.FileExists(). If /bin/sh does not exist, the provider is not available.",
    "tags": [],
    "title": "Shell Provider",
    "uri": "/design/exec/shell/index.html"
  },
  {
    "breadcrumb": "Introduction",
    "content": "Just like applications need data to vary their behavior and configure their environments, so do Configuration Management tools.\nFor this reason, I wrote extlookup and hiera years ago for the Puppet community. Despite CCM’s minimal focus, we still need data to vary behavior.\nData can be used for:\nConfiguring resource names that differ between operating systems (e.g., httpd vs apache2) Setting different configuration values depending on environment, role, or other dimensions Deciding whether environments should have something installed (e.g., development vs production) CCM supports various data sources:\nSystem Facts - Operating system, networking, and disk configuration Custom Facts - From /etc/choria/ccm/facts.{yaml,json} and ~/.config/choria/ccm/facts.{yaml,json} Environment - Variables from the shell environment and ./.env files Hiera Data - Hierarchical data with overrides based on facts Accessing Data Expressions like {{ lookup('facts.host.info.platformFamily') }} use the Expr Language.\nAvailable Variables In templates, you have direct access to:\nVariable Description Facts System facts (e.g., Facts.host.info.platformFamily) Data Resolved Hiera data (e.g., Data.package_name) Environ Environment variables (e.g., Environ.HOME) Available Functions Function Description lookup(key, default) Lookup data using GJSON Path Syntax. Example: lookup(\"facts.host.info.os\", \"linux\") readFile(path), file(path) Read a file into a string (files must be in the working directory) template(f) Parse f using templates. If f ends in .templ, reads the file first, if it ends in .jet calls the jet() function jet(f), jet(f, \"[[\", \"]]\") Parse f using Jet templates with optional custom delimiters. If f ends in .jet, reads the file first GJSON Path Examples The lookup() function uses GJSON path syntax for nested access:\nlookup(\"facts.host.info.platformFamily\") # Simple nested path lookup(\"facts.network.interfaces.0.name\") # Array index lookup(\"data.packages.#\") # Array length CLI Usage These expressions work on the CLI:\n$ ccm ensure package '{{ lookup(\"data.package_name\", \"httpd\") }}' This fetches package_name from the data and defaults to httpd if not found.\nFacts CCM includes a built-in fact resolver that gathers system information. To see available facts:\n$ ccm facts # All facts as JSON $ ccm facts host # Query specific path $ ccm facts --yaml # Output as YAML Access facts in expressions using {{ Facts.host.info.platformFamily }} or {{ lookup('facts.host.info.platformFamily') }}.\nHiera Data for CLI Hiera data is resolved using the Choria Hierarchical Data Resolver. By default, data is read from ./.hiera, or you can specify a file with --hiera.\nNote This applies to ccm ensure commands. The ccm apply command uses manifests that contain their own Hiera data.\nHiera Data Sources Hiera data can be loaded from:\nLocal file: ./.hiera or path specified with --hiera Key-Value store: --hiera kv://BUCKET/key (requires --context for NATS) HTTP(S): --hiera https://example.com/data.yaml (supports Basic Auth via URL credentials) Merge Strategies The hierarchy.merge setting controls how overrides are applied:\nfirst (default): Stops at the first matching override deep: Deep merges all matching overrides in order Example Given this file stored in ./.hiera:\nhierarchy: order: - os:{{ lookup('facts.host.info.platformFamily') }} merge: first data: package_name: \"\" overrides: os:debian: package_name: apache2 os:rhel: package_name: httpd Running ccm ensure package '{{ lookup(\"data.package_name\") }}' installs httpd on RHEL-based systems and apache2 on Debian-based systems.\nNote See the Hiera section for details on configuring Hiera data in NATS.\nEnvironment The shell environment and variables defined in ./.env can be accessed in two ways:\n# Direct access home_dir: \"{{ Environ.HOME }}\" # Via lookup (with default value) my_var: \"{{ lookup('environ.MY_VAR', 'default') }}\" The .env file uses standard KEY=value format, one variable per line.",
    "description": "Just like applications need data to vary their behavior and configure their environments, so do Configuration Management tools.\nFor this reason, I wrote extlookup and hiera years ago for the Puppet community. Despite CCM’s minimal focus, we still need data to vary behavior.\nData can be used for:\nConfiguring resource names that differ between operating systems (e.g., httpd vs apache2) Setting different configuration values depending on environment, role, or other dimensions Deciding whether environments should have something installed (e.g., development vs production) CCM supports various data sources:",
    "tags": [],
    "title": "Data",
    "uri": "/data/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Design Documents",
    "content": "This document describes the design of the file resource type for managing files and directories.\nOverview The file resource manages files and directories with three aspects:\nExistence: Whether the file/directory exists or is absent Content: The contents of a file (from inline content or source file) Attributes: Owner, group, and permissions Provider Interface File providers must implement the FileProvider interface:\ntype FileProvider interface { model.Provider CreateDirectory(ctx context.Context, dir string, owner string, group string, mode string) error Store(ctx context.Context, file string, contents []byte, source string, owner string, group string, mode string) error Status(ctx context.Context, file string) (*model.FileState, error) } Method Responsibilities Method Responsibility Status Query current file state (existence, type, content hash, attributes) Store Create or update a file with content and attributes CreateDirectory Create a directory with attributes Status Response The Status method returns a FileState containing:\ntype FileState struct { CommonResourceState Metadata *FileMetadata } type FileMetadata struct { Name string // File path Checksum string // SHA256 hash of contents (files only) Owner string // Owner username Group string // Group name Mode string // Permissions in octal (e.g., \"0644\") Provider string // Provider name (e.g., \"posix\") MTime time.Time // Modification time Size int64 // File size in bytes Extended map[string]any // Provider-specific metadata } The Ensure field in CommonResourceState is set to:\npresent if a regular file exists directory if a directory exists absent if the path does not exist Available Providers Provider Platform Documentation posix Unix/Linux Posix Ensure States Value Description present Path must be a regular file with specified content absent Path must not exist directory Path must be a directory Content Sources Files can receive content from two mutually exclusive sources:\nProperty Description contents Inline string content (template-resolved) source Path to local file to copy from # Inline content with template - file: - /etc/motd: ensure: present content: | Welcome to {{ lookup('facts.hostname') }} Managed by CCM owner: root group: root mode: \"0644\" # Copy from source file - file: - /etc/app/config.yaml: ensure: present source: files/config.yaml owner: app group: app mode: \"0640\" When using source, the path is relative to the manifest’s working directory if one is set.\nRequired Properties Unlike some resources, file resources require explicit attributes:\nProperty Required Description owner Yes Username that owns the file group Yes Group that owns the file mode Yes Permissions in octal notation This prevents accidental creation of files with default or inherited permissions.\nApply Logic ┌─────────────────────────────────────────┐ │ Get current state via Status() │ └─────────────────┬───────────────────────┘ │ ▼ ┌─────────────────────────────────────────┐ │ Is current state desired state? │ └─────────────────┬───────────────────────┘ Yes │ No ▼ │ ┌───────────┐ │ │ No change │ │ └───────────┘ │ ▼ ┌─────────────────────────┐ │ What is desired ensure? │ └─────────────┬───────────┘ │ ┌───────────────────────┼───────────────────────┐ │ absent │ directory │ present ▼ ▼ ▼ ┌────────────┐ ┌───────────────┐ ┌───────────────┐ │ Remove │ │ CreateDir │ │ Store │ │ (os.Remove)│ │ │ │ │ └────────────┘ └───────────────┘ └───────────────┘ Idempotency The file resource checks multiple attributes for idempotency:\nState Checks (in order) Ensure match: Current type matches desired (present/absent/directory) Content match: SHA256 checksum of contents matches (for ensure: present) Owner match: Current owner matches desired Group match: Current group matches desired Mode match: Current permissions match desired Decision Table Desired Current State Action absent absent None absent present/directory Remove directory directory + matching attrs None directory absent/present CreateDirectory directory directory + wrong attrs CreateDirectory (updates attrs) present present + matching all None present absent Store present present + wrong content Store present present + wrong attrs Store Content Comparison Content is compared using SHA256 checksums:\nSource Checksum Method contents property Sha256HashBytes([]byte(contents)) source property Sha256HashFile(adjustedPath) Existing file Sha256HashFile(filePath) Mode Validation File modes are validated during resource creation:\nValid Formats:\n\"0644\" - Standard octal \"644\" - Without leading zero \"0o755\" - With 0o prefix \"0O700\" - With 0O prefix Validation Rules:\nMust be valid octal number (digits 0-7) Must be ≤ 0777 (no setuid/setgid/sticky via mode) Path Validation File paths must be:\nAbsolute (start with /) Clean (no . or .. components, filepath.Clean(path) == path) if filepath.Clean(p.Name) != p.Name { return fmt.Errorf(\"file path must be absolute\") } Working Directory When a manifest has a working directory (e.g., extracted from an archive), the source property is resolved relative to it:\nif properties.Source != \"\" \u0026\u0026 mgr.WorkingDirectory() != \"\" { source = filepath.Join(mgr.WorkingDirectory(), properties.Source) } This allows manifests bundled with their source files to use relative paths.\nNoop Mode In noop mode, the file type:\nQueries current state normally Computes content checksums Logs what actions would be taken Sets appropriate NoopMessage: “Would have created the file” “Would have created directory” “Would have removed the file” Reports Changed: true if changes would occur Does not call provider Store/CreateDirectory methods Does not remove files Desired State Validation After applying changes (in non-noop mode), the type verifies the file reached the desired state by calling Status() again and checking all attributes match. If validation fails, ErrDesiredStateFailed is returned.",
    "description": "This document describes the design of the file resource type for managing files and directories.\nOverview The file resource manages files and directories with three aspects:\nExistence: Whether the file/directory exists or is absent Content: The contents of a file (from inline content or source file) Attributes: Owner, group, and permissions Provider Interface File providers must implement the FileProvider interface:",
    "tags": [],
    "title": "File Type",
    "uri": "/design/file/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Design Documents",
    "content": "This document describes the design of the package resource type for managing software packages.\nOverview The package resource manages software packages with two aspects:\nExistence: Whether the package is installed or absent Version: The specific version installed (when applicable) Provider Interface Package providers must implement the PackageProvider interface:\ntype PackageProvider interface { model.Provider Install(ctx context.Context, pkg string, version string) error Upgrade(ctx context.Context, pkg string, version string) error Downgrade(ctx context.Context, pkg string, version string) error Uninstall(ctx context.Context, pkg string) error Status(ctx context.Context, pkg string) (*model.PackageState, error) VersionCmp(versionA, versionB string, ignoreTrailingZeroes bool) (int, error) } Method Responsibilities Method Responsibility Status Query current package state (installed version or absent) Install Install package at specified version (or latest if “latest”) Upgrade Upgrade package to specified version Downgrade Downgrade package to specified version Uninstall Remove the package VersionCmp Compare two version strings (-1, 0, 1) Status Response The Status method returns a PackageState containing:\ntype PackageState struct { CommonResourceState Metadata *PackageMetadata } type PackageMetadata struct { Name string // Package name Version string // Installed version Arch string // Architecture (e.g., \"x86_64\") License string // Package license URL string // Package URL Summary string // Short description Description string // Full description Provider string // Provider name (e.g., \"dnf\") Extended map[string]any // Provider-specific metadata } The Ensure field in CommonResourceState is set to:\nThe installed version string if the package is installed absent if the package is not installed Available Providers Provider Package Manager Documentation dnf DNF (Fedora/RHEL) DNF apt APT (Debian/Ubuntu) APT Ensure States Value Description present Package must be installed (any version) absent Package must not be installed latest Package must be upgraded to latest available \u003cversion\u003e Package must be at specific version # Install any version - package: - vim: ensure: present # Install latest version - package: - vim: ensure: latest # Install specific version - package: - nginx: ensure: \"1.24.0-1.el9\" # Remove package - package: - telnet: ensure: absent Apply Logic Phase 1: Handle Special Cases ┌─────────────────────────────────────────┐ │ Get current state via Status() │ └─────────────────┬───────────────────────┘ │ ▼ ┌─────────────────────────────────────────┐ │ Is ensure = \"latest\"? │ └─────────────────┬───────────────────────┘ Yes │ No ▼ │ ┌─────────────────────┐ │ │ Is package absent? │ │ └─────────────┬───────┘ │ Yes │ No │ ▼ ▼ │ ┌────────┐ ┌────────┐ │Install │ │Upgrade │ │latest │ │latest │ └────────┘ └────────┘ │ ▼ ┌─────────────────────────┐ │ Is desired state met? │ └─────────────┬───────────┘ Yes │ No ▼ │ ┌───────────┐ │ │ No change │ ▼ └───────────┘ (Phase 2) Phase 2: Handle Ensure Values ┌─────────────────────────┐ │ What is desired ensure? │ └─────────────┬───────────┘ │ ┌───────────────────────┼───────────────────────┐ │ absent │ present │ \u003cversion\u003e ▼ ▼ ▼ ┌────────────┐ ┌───────────────┐ ┌───────────────┐ │ Uninstall │ │ Is absent? │ │ Is absent? │ └────────────┘ └───────┬───────┘ └───────┬───────┘ Yes │ No Yes │ No ▼ ▼ ▼ ▼ ┌────────┐ ┌────────┐ ┌────────┐ ┌────────────┐ │Install │ │No │ │Install │ │Compare │ │ │ │change │ │version │ │versions │ └────────┘ └────────┘ └────────┘ └─────┬──────┘ │ ┌────────────────┼────────────────┐ │ current \u003c │ current = │ current \u003e ▼ ▼ ▼ ┌───────────┐ ┌───────────┐ ┌───────────┐ │ Upgrade │ │ No change │ │ Downgrade │ └───────────┘ └───────────┘ └───────────┘ Version Comparison The VersionCmp method compares two version strings:\nReturn Value Meaning -1 versionA \u003c versionB (upgrade needed) 0 versionA == versionB (no change) 1 versionA \u003e versionB (downgrade needed) Version comparison is delegated to the provider, allowing platform-specific version parsing (e.g., RPM epoch handling, Debian revision suffixes).\nIdempotency The package resource is idempotent through state comparison:\nDecision Table Desired Current State Action ensure: present installed (any version) None ensure: present absent Install ensure: absent absent None ensure: absent installed Uninstall ensure: latest absent Install latest ensure: latest installed Upgrade (always runs) ensure: \u003cversion\u003e same version None ensure: \u003cversion\u003e older version Upgrade ensure: \u003cversion\u003e newer version Downgrade ensure: \u003cversion\u003e absent Install Special Case: ensure: latest When ensure: latest is used:\nThe package manager determines what “latest” means Upgrade is always called when the package exists (package manager is idempotent) The type cannot verify if “latest” was achieved (package managers may report stale data) Desired state validation only checks that the package is not absent Package Name Validation Package names are validated to prevent injection attacks:\nAllowed Characters:\nAlphanumeric (a-z, A-Z, 0-9) Period (.), underscore (_), plus (+) Colon (:), tilde (~), hyphen (-) Rejected:\nShell metacharacters (;, |, \u0026, $, etc.) Whitespace Quotes and backticks Path separators Version strings (when ensure is a version) are also validated for dangerous characters.\nNoop Mode In noop mode, the package type:\nQueries current state normally Computes version comparison Logs what actions would be taken Sets appropriate NoopMessage: “Would have installed latest” “Would have upgraded to latest” “Would have installed version X” “Would have upgraded to X” “Would have downgraded to X” “Would have uninstalled” Reports Changed: true if changes would occur Does not call provider Install/Upgrade/Downgrade/Uninstall methods Desired State Validation After applying changes (in non-noop mode), the type verifies the package reached the desired state:\nfunc (t *Type) isDesiredState(properties, state) bool { switch properties.Ensure { case \"present\": // Any installed version is acceptable return state.Ensure != \"absent\" case \"absent\": return state.Ensure == \"absent\" case \"latest\": // Cannot verify \"latest\", just check not absent return state.Ensure != \"absent\" default: // Specific version must match return VersionCmp(state.Ensure, properties.Ensure, false) == 0 } } If the desired state is not reached, an ErrDesiredStateFailed error is returned.",
    "description": "This document describes the design of the package resource type for managing software packages.\nOverview The package resource manages software packages with two aspects:\nExistence: Whether the package is installed or absent Version: The specific version installed (when applicable) Provider Interface Package providers must implement the PackageProvider interface:",
    "tags": [],
    "title": "Package Type",
    "uri": "/design/package/index.html"
  },
  {
    "breadcrumb": "Introduction",
    "content": "CCM is designed as a CLI-first tool. Each resource type has its own subcommand under ccm ensure, with required inputs as arguments and optional settings as flags.\nThe ccm ensure commands are idempotent, making them safe to run multiple times in shell scripts.\nUse ccm --help and ccm \u003ccommand\u003e --help to explore available commands and options.\nManaging a Single Resource Managing a single resource is straightforward.\nccm ensure package zsh 5.8 This ensures the package zsh is installed at version 5.8.\nTo view the current state of a resource:\nccm status package zsh Managing Multiple Resources When managing multiple resources in a script, create a session first. The session records the outcome of each resource, enabling features like refreshing a service when a file changes.\n#!/bin/bash eval \"$(ccm session new)\" trap 'rm -rf -- \"$CCM_SESSION_STORE\"' EXIT ccm ensure package httpd ccm ensure file /etc/httpd/conf/httpd.conf .... --require package#httpd ccm ensure service httpd --subscribe file#/etc/httpd/conf/httpd.conf ccm session report This creates a temporary directory for session state. If the file resource changes, the service restarts automatically.\nIf you prefer not to eval command output, use: export CCM_SESSION_STORE=$(mktemp -d)\nData in the CLI As covered in the data section, commands automatically read ./.env and ./.hiera files, merging that data into the session.\nUse the --hiera flag or CCM_HIERA_DATA environment variable to specify a different data file.\nWith data loaded, you can access:\n{{ lookup(\"data.my_data_key\") }} for Hiera data {{ lookup(\"env.MY_ENV_VAR\") }} for environment variables {{ lookup(\"facts.host.info.platformFamily\") }} for system facts Example using Hiera data:\nccm ensure package '{{ lookup(\"data.package\") }}' '{{ lookup(\"data.version\") }}' Expressions use the Expr Language, enabling complex logic:\n$ ccm ensure package '{{ lookup(\"facts.host.info.platformFamily\") == \"rhel\" ? \"httpd\" : \"apache2\" }}' WARN package#httpd changed ensure=present runtime=14.509s provider=dnf For complex conditional logic, we recommend using Hiera data with hierarchy overrides instead.\nApplying Manifests For non-shell script usage use YAML manifests with ccm apply:\nSee YAML Manifests for manifest format details.\nViewing System Facts CCM gathers system facts that can be used in templates and conditions:\n# Show all facts as JSON $ ccm facts # Show facts as YAML $ ccm facts --yaml # Query specific facts using gjson syntax $ ccm facts host.info.platformFamily Resolving Hiera Data The ccm hiera command helps debug and test Hiera data resolution:\n# Resolve a Hiera file with system facts $ ccm hiera parse data.yaml -S # Resolve with custom facts $ ccm hiera parse data.yaml os=linux env=production # Query a specific key from the result $ ccm hiera parse data.yaml --query packages",
    "description": "CCM is designed as a CLI-first tool. Each resource type has its own subcommand under ccm ensure, with required inputs as arguments and optional settings as flags.\nThe ccm ensure commands are idempotent, making them safe to run multiple times in shell scripts.\nUse ccm --help and ccm \u003ccommand\u003e --help to explore available commands and options.\nManaging a Single Resource Managing a single resource is straightforward.",
    "tags": [],
    "title": "Shell Usage",
    "uri": "/cli/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Design Documents",
    "content": "This document describes the design of the service resource type for managing system services.\nOverview The service resource manages system services with two independent dimensions:\nRunning state: Whether the service is currently running or stopped Enabled state: Whether the service starts automatically at boot These are managed independently, allowing combinations like “running but disabled” or “stopped but enabled”.\nProvider Interface Service providers must implement the ServiceProvider interface:\ntype ServiceProvider interface { model.Provider Enable(ctx context.Context, service string) error Disable(ctx context.Context, service string) error Start(ctx context.Context, service string) error Stop(ctx context.Context, service string) error Restart(ctx context.Context, service string) error Status(ctx context.Context, service string) (*model.ServiceState, error) } Method Responsibilities Method Responsibility Status Query current running and enabled state Start Start the service if not running Stop Stop the service if running Restart Stop and start the service (for refresh) Enable Configure service to start at boot Disable Configure service to not start at boot Status Response The Status method returns a ServiceState containing:\ntype ServiceState struct { CommonResourceState Metadata *ServiceMetadata } type ServiceMetadata struct { Name string // Service name Provider string // Provider name (e.g., \"systemd\") Enabled bool // Whether service starts at boot Running bool // Whether service is currently running } The Ensure field in CommonResourceState is set to:\nrunning if the service is active stopped if the service is inactive Available Providers Provider Init System Documentation systemd systemd Systemd Ensure States Value Description running Service must be running (default) stopped Service must be stopped If ensure is not specified, it defaults to running.\nEnable Property The enable property is a boolean pointer (*bool) with three possible states:\nValue Behavior true Enable service to start at boot false Disable service from starting at boot nil (not set) Leave boot configuration unchanged This allows managing running state without affecting boot configuration:\n# Start service but don't change boot config - service: - myapp: ensure: running # Start and enable at boot - service: - myapp: ensure: running enable: true # Stop and disable at boot - service: - myapp: ensure: stopped enable: false Apply Logic The service type applies changes in two phases:\nPhase 1: Running State ┌─────────────────────────────────────────┐ │ Check for subscribe refresh │ └─────────────────┬───────────────────────┘ │ ┌─────────────┴─────────────┐ │ Subscribed resource │ │ changed? │ └─────────────┬─────────────┘ Yes │ │ No ▼ │ ┌─────────────────────┐ │ │ ensure=running? │ │ │ already running? │ │ └─────────────┬───────┘ │ Yes+Yes │ │ ▼ │ ┌───────────┐ │ │ Restart │ │ └───────────┘ │ ▼ ┌─────────────────────────┐ │ Compare ensure vs state │ └─────────────┬───────────┘ │ ┌───────────────────────┼───────────────────────┐ │ ensure=stopped │ ensure=running │ │ state=running │ state=stopped │ ▼ ▼ │ ┌────────┐ ┌────────┐ │ │ Stop │ │ Start │ │ └────────┘ └────────┘ │ ▼ ┌───────────────┐ │ No change │ └───────────────┘ Phase 2: Enabled State After running state is handled, enabled state is processed:\n┌─────────────────────────────────────────┐ │ enable property set? │ └─────────────────┬───────────────────────┘ │ nil │ true/false ▼ │ ┌───────────┐ │ │ No change │ │ └───────────┘ │ ▼ ┌─────────────────────────────┐ │ Compare enable vs enabled │ └─────────────┬───────────────┘ │ ┌─────────────┼─────────────┐ │ enable=true │ enable=false│ │ !enabled │ enabled │ ▼ ▼ │ ┌────────┐ ┌─────────┐ │ │ Enable │ │ Disable │ │ └────────┘ └─────────┘ │ ▼ ┌───────────────┐ │ No change │ └───────────────┘ Subscribe Behavior Services can subscribe to other resources and restart when they change:\n- service: - httpd: ensure: running subscribe: - file#/etc/httpd/conf/httpd.conf - package#httpd Special Cases:\nCondition Behavior ensure: stopped Subscribe ignored (no restart) Service not running + ensure: running Start (not restart) Service running + ensure: running Restart This prevents restarting stopped services and ensures a clean start when the service should be running but isn’t.\nIdempotency The service resource is idempotent through state comparison:\nDesired Current Action ensure: running running None ensure: running stopped Start ensure: stopped stopped None ensure: stopped running Stop enable: true enabled None enable: true disabled Enable enable: false enabled Disable enable: false disabled None enable: nil any None Desired State Validation After applying changes, the type verifies the service reached the desired state:\nfunc (t *Type) isDesiredState(properties, state) bool { // Check running state if properties.Ensure != state.Ensure { return false } // Check enabled state (only if explicitly set) if properties.Enable != nil { if *properties.Enable != state.Metadata.Enabled { return false } } return true } If the desired state is not reached, an ErrDesiredStateFailed error is returned.\nService Name Validation Service names are validated to prevent injection attacks:\nAllowed Characters:\nAlphanumeric (a-z, A-Z, 0-9) Period (.), underscore (_), plus (+) Colon (:), tilde (~), hyphen (-) Rejected:\nShell metacharacters (;, |, \u0026, etc.) Whitespace Path separators Noop Mode In noop mode, the service type:\nQueries current state normally Logs what actions would be taken Sets appropriate NoopMessage (e.g., “Would have started”, “Would have enabled”) Reports Changed: true if changes would occur Does not call provider Start/Stop/Restart/Enable/Disable methods",
    "description": "This document describes the design of the service resource type for managing system services.\nOverview The service resource manages system services with two independent dimensions:\nRunning state: Whether the service is currently running or stopped Enabled state: Whether the service starts automatically at boot These are managed independently, allowing combinations like “running but disabled” or “stopped but enabled”.",
    "tags": [],
    "title": "Service Type",
    "uri": "/design/service/index.html"
  },
  {
    "breadcrumb": "Introduction",
    "content": "A manifest is a YAML file that combines data, hierarchy configuration, and resources in a single file.\nManifests support template expressions but not procedural logic. Think of them as declarative configuration similar to multi-resource shell scripts.\nNote A JSON Schema for manifests is available at https://choria.io/schemas/ccm/v1/manifest.json. Configure your editor to use this schema for completion and validation.\nManifest Structure A manifest contains these top-level sections:\nSection Description data Input data (like module parameters) hierarchy Lookup order and merge strategy for overrides overrides Data overrides keyed by hierarchy entries ccm Resource definitions and execution options The manifest is resolved using the Choria Hierarchical Data Resolver.\nFull Example Input Data Define input data like parameters for a module:\ndata: package_name: \"httpd\" Resources Define resources to manage in the ccm section:\nccm: resources: - package: - \"{{ lookup('data.package_name') }}\": ensure: latest Configure Hierarchy Configure a hierarchy to vary data by dimensions like OS platform:\nhierarchy: order: - os:{{ lookup('facts.host.info.platformFamily') }} This looks for overrides in os:rhel, os:debian, etc.\nOverrides Provide platform-specific data overrides:\noverrides: os:debian: package_name: apache2 Applying Manifests The complete manifest:\ndata: package_name: \"httpd\" ccm: resources: - package: - \"{{ lookup('data.package_name') }}\": ensure: latest hierarchy: order: - os:{{ lookup('facts.host.info.platformFamily') }} overrides: os:debian: package_name: apache2 Apply the manifest with ccm apply. The first run makes changes; subsequent runs are stable:\n$ ccm apply manifest.yaml INFO Creating new session record resources=1 WARN package#httpd changed ensure=latest runtime=3.560699287s provider=dnf $ ccm apply manifest.yaml INFO Creating new session record resources=1 INFO package#httpd stable ensure=latest runtime=293.448824ms provider=dnf To preview the fully resolved manifest without applying it:\n$ ccm apply manifest.yaml --render data: package_name: apache2 resources: - package: - apache2: ensure: latest Pre and Post Messages Display messages before and after manifest execution:\nccm: pre_message: | Starting configuration update... post_message: | Configuration complete. resources: - ... Both are optional.\nOverriding Data Override or augment manifest data with an external Hiera source:\nccm apply manifest.yaml --hiera kv://CCM/common Supported sources include local files, KV stores (kv://), and HTTP(S) URLs.\nSetting Defaults Reduce repetition by setting defaults for resources of the same type:\nccm: resources: - file: - defaults: owner: app group: app mode: \"0644\" ensure: present - /app/config/file.conf: source: file.conf - /app/bin/app: source: app.bin mode: \"0700\" - file: - /etc/motd: ensure: present source: motd.txt owner: root group: root mode: \"0644\" The first two files inherit the defaults values. The /app/bin/app file overrides just the mode. The /etc/motd file is a separate resource block, so defaults do not apply.\nTemplating Manifests support template expressions like {{ lookup(\"key\") }} for adjusting values. These expressions cannot generate new resources; they only modify values in valid YAML.\nAvailable Variables Templates have access to:\nVariable Description Facts System facts Data Resolved Hiera data Environ Environment variables Generating Resources with Jet Templates To dynamically generate resources from data, use Jet Templates.\nGiven this data:\ndata: common_packages: - zsh - vim-enhanced - nagios-plugins-all - tar - nmap-ncat Reference a Jet template file instead of inline resources:\nccm: resources_jet_file: resources.jet Create the template file:\n{* resources.jet *} [[ range Data.common_packages ]] - package: - [[ . ]]: ensure: present [[ end ]] Note The template file must be in the same directory as the manifest.\nThe template receives the fully resolved Hiera data, plus Facts and Environ.\nFailure Handling By default, if a resource fails, the apply continues to the next resource.\nFail on Error To stop execution on the first failure, set fail_on_error:\nccm: fail_on_error: true resources: - exec: - /usr/bin/false: {} - /usr/bin/true: {} The second resource is never executed:\n$ ccm apply manifest.yaml INFO Executing manifest manifest=manifest.yaml resources=2 ERROR exec#/usr/bin/false failed ensure=present runtime=3ms provider=posix errors=failed to reach desired state exit code 1 WARN Terminating manifest execution due to failed resource Resource Dependencies Use the require property to ensure a resource only runs after its dependencies succeed:\nccm: resources: - package: - httpd: ensure: present - file: - /etc/httpd/conf.d/custom.conf: ensure: present content: \"Listen 8080\" owner: root group: root mode: \"0644\" require: - package#httpd If the required resource fails, the dependent resource is skipped.\nDry Run (Noop Mode) Preview changes without applying them:\nccm apply manifest.yaml --noop Note Noop mode cannot always detect cascading effects. If one resource change would affect a later resource, that dependency may not be reflected in the dry run.\nHealth Check Only Mode Run only health checks without applying resources:\nccm apply manifest.yaml --monitor-only This is useful for verifying system state without making changes.\nManifests in NATS Object Store Manifests can be stored in NATS Object Stores, avoiding the need to distribute files locally.\nConfigure a NATS context for authentication:\nnats context add ccm --server nats.example.org --user ccm --password s3cret \\ --description \"CCM Configuration Store\" Create an Object Store:\nnats obj add CCM --replicas 3 --context ccm Create a manifest with supporting files:\n$ mkdir /tmp/manifest $ echo 'CCM Managed' \u003e /tmp/manifest/motd $ cat \u003e /tmp/manifest/manifest.yaml \u003c\u003c 'EOF' ccm: resources: - file: - /etc/motd: ensure: present source: motd owner: root group: root mode: \"0644\" EOF Package and upload to the Object Store:\n$ tar -C /tmp/manifest/ -cvzf /tmp/manifest.tgz . $ nats obj put CCM manifest.tgz --context ccm Apply the manifest:\n$ ccm apply obj://CCM/manifest.tgz --context ccm INFO Using manifest from Object Store in temporary directory bucket=CCM file=manifest.tgz INFO file#/etc/motd stable ensure=present runtime=0s provider=posix Manifests on Web Servers Store gzipped tar archives on a web server and apply them directly:\n$ ccm apply https://example.net/manifest.tar.gz INFO Executing manifest manifest=https://example.net/manifest.tar.gz resources=1 INFO file#/etc/motd stable ensure=present runtime=0s provider=posix HTTP Basic Auth is supported via URL credentials:\nccm apply https://user:pass@example.net/manifest.tar.gz Additional Facts Provide additional facts from the command line or a file:\n# Individual facts $ ccm apply manifest.yaml --fact env=production --fact region=us-east # Facts from a file $ ccm apply manifest.yaml --facts custom-facts.yaml Facts from these sources are merged with system facts, with command-line facts taking precedence.",
    "description": "A manifest is a YAML file that combines data, hierarchy configuration, and resources in a single file.\nManifests support template expressions but not procedural logic. Think of them as declarative configuration similar to multi-resource shell scripts.\nNote A JSON Schema for manifests is available at https://choria.io/schemas/ccm/v1/manifest.json. Configure your editor to use this schema for completion and validation.\nManifest Structure A manifest contains these top-level sections:",
    "tags": [],
    "title": "YAML Manifests",
    "uri": "/yamlmanifests/index.html"
  },
  {
    "breadcrumb": "Introduction",
    "content": "For certain use cases, it is useful to run YAML Manifests continuously. For example, you might not want to manage your dotfiles automatically (allowing for local modifications), but you do want to keep Docker up to date.\nThe CCM Agent runs manifests continuously, loading them from local files, Object Storage, or HTTP(S) URLs, with Key-Value data overlaid.\nIn time, the Agent will become a key part of a service registry system, allowing for continuous monitoring of managed resources and sharing that state into a registry—enabling other nodes to use file resources to create configurations that combine knowledge of all nodes.\nRun Modes The agent supports two modes of operation that combine to be efficient and fast-reacting:\nFull manifest apply: Manages the complete state of every resource Health check mode: Runs only Monitoring checks, which can trigger a full manifest apply as remediation By enabling both modes, you can run health checks very frequently (even at 10- or 20-second intervals) while keeping full Configuration Management runs less frequent (every few hours).\nEnabling both modes is optional but recommended. We also recommend adding health checks to your key resources.\nSupported Manifest and Data Sources Manifest Sources Manifests can be loaded from:\nLocal file: /path/to/manifest.yaml Object Storage: obj://bucket/key.tar.gz HTTP(S): https://example.com/manifest.tar.gz (supports Basic Auth via URL credentials) Remote sources (Object Storage and HTTP) must be .tar.gz archives containing a manifest.yaml file, templates and file sources.\nExternal Data Sources For Hiera data resolution, the agent supports:\nLocal file: file:///path/to/data.yaml Key-Value store: kv://bucket/key HTTP(S): https://example.com/data.yaml Logical Flow The agent continuously runs and manages manifests as follows:\nAt startup, the agent fetches data and gathers facts Starts a worker for each manifest source Each worker starts watchers to download and manage the manifest (polling every 30 seconds for remote sources) Triggers workers at the configured interval for a full apply Each run updates facts (minimum 2-minute interval) and data Applies each manifest serially Triggers workers at the configured health check interval Health check runs do not update facts or data Runs health checks for each manifest serially If any health checks are critical (not warning), the agent triggers a full apply for that worker In the background, object stores and HTTP sources are watched for changes. Updates trigger immediate apply runs with exponential backoff retry on failures.\nPrometheus Metrics When monitor_port is configured, the agent exposes Prometheus metrics on /metrics. These metrics can be used to monitor agent health, track resource states and events, and observe health check statuses.\nAgent Metrics Metric Type Labels Description choria_ccm_agent_apply_duration_seconds Summary manifest Time taken to apply manifests choria_ccm_agent_healthcheck_duration_seconds Summary manifests Time taken for health check runs choria_ccm_agent_healthcheck_remediations_count Counter manifest Health checks that triggered remediation choria_ccm_agent_data_resolve_duration_seconds Summary - Time taken to resolve external data choria_ccm_agent_data_resolve_error_count Counter url Data resolution failures choria_ccm_agent_facts_resolve_duration_seconds Summary - Time taken to resolve facts choria_ccm_agent_facts_resolve_error_count Counter - Facts resolution failures choria_ccm_agent_manifest_fetch_count Counter manifest Remote manifest fetches choria_ccm_agent_manifest_fetch_error_count Counter manifest Remote manifest fetch failures Resource Metrics Metric Type Labels Description choria_ccm_manifest_apply_duration_seconds Summary source Time taken to apply an entire manifest choria_ccm_resource_apply_duration_seconds Summary type, provider, name Time taken to apply a resource choria_ccm_resource_state_total_count Counter type, name Total resources processed choria_ccm_resource_state_stable_count Counter type, name Resources in stable state choria_ccm_resource_state_changed_count Counter type, name Resources that changed choria_ccm_resource_state_refreshed_count Counter type, name Resources that were refreshed choria_ccm_resource_state_failed_count Counter type, name Resources that failed choria_ccm_resource_state_error_count Counter type, name Resources with errors choria_ccm_resource_state_skipped_count Counter type, name Resources that were skipped choria_ccm_resource_state_noop_count Counter type, name Resources in noop mode Health Check Metrics Metric Type Labels Description choria_ccm_healthcheck_duration_seconds Summary type, name, check Time taken for health checks choria_ccm_healthcheck_status_count Counter type, name, status, check Health check results by status Facts Metrics Metric Type Labels Description choria_ccm_facts_gather_duration_seconds Summary - Time taken to gather system facts Configuration The agent is included in the ccm binary. To use it, create a configuration file and enable the systemd service.\nThe configuration file is located at /etc/choria/ccm/config.yaml:\n# CCM Agent Configuration Example # Time between scheduled manifest apply runs. # Must be at least 30s. Defaults to 5m. interval: 5m # Time between health check runs. # When set, health checks run independently of apply runs and can trigger # remediation applies when critical issues are detected. # Omit to disable periodic health checks. health_check_interval: 1m # List of manifest sources to apply. Each source creates a separate worker. # Supported formats: # - Local file: /path/to/manifest.yaml # - Object store: obj://bucket/key.tar.gz # - HTTP(S): https://example.com/manifest.tar.gz # - HTTP with Basic Auth: https://user:pass@example.com/manifest.tar.gz # Remote sources must be .tar.gz archives containing a manifest.yaml file. manifests: - /etc/choria/ccm/manifests/base.yaml - obj://ccm-manifests/app.tar.gz - https://config.example.com/manifests/web.tar.gz # Logging level: debug, info, warn, error log_level: info # NATS context for authentication. Defaults to 'CCM'. nats_context: CCM # Optional URL for external Hiera data resolution. # Supported formats: file://, kv://, http(s):// # The resolved data is merged into the manifest data context. external_data_url: kv://ccm-data/common # Directory for caching remote manifest sources. # Defaults to /etc/choria/ccm/source. cache_dir: /etc/choria/ccm/source # Port for Prometheus metrics endpoint (/metrics). # Set to 0 or omit to disable. monitor_port: 9100 After configuring, start the service:\nccm ensure service ccm-agent running --enable",
    "description": "For certain use cases, it is useful to run YAML Manifests continuously. For example, you might not want to manage your dotfiles automatically (allowing for local modifications), but you do want to keep Docker up to date.\nThe CCM Agent runs manifests continuously, loading them from local files, Object Storage, or HTTP(S) URLs, with Key-Value data overlaid.\nIn time, the Agent will become a key part of a service registry system, allowing for continuous monitoring of managed resources and sharing that state into a registry—enabling other nodes to use file resources to create configurations that combine knowledge of all nodes.",
    "tags": [],
    "title": "Agent",
    "uri": "/agent/index.html"
  },
  {
    "breadcrumb": "Introduction",
    "content": "By default, CCM verifies resource health using the resource’s native state. For example, if a service should be running and systemd reports it as running, CCM considers it healthy.\nFor deeper validation, all resources support custom health checks. These checks run after a resource is managed and can verify that the resource is functioning correctly, not just present.\nHealth Check Properties Property Description Default command Command to execute (required) - name Name for logging and metrics Command base name tries Number of attempts before failing 1 try_sleep Duration to wait between retry attempts 1s timeout Maximum time for command execution No timeout format Output format interpretation nagios Nagios Format Health checks use Nagios plugin conventions for exit codes:\nExit Code Status Description 0 OK Check passed 1 WARNING Check passed with warnings (non-critical) 2 CRITICAL Check failed 3+ UNKNOWN Check could not determine status Example ​ Manifest CLI - service: - httpd: ensure: running enable: true health_checks: - name: check_http command: | /usr/lib64/nagios/plugins/check_http -H localhost -p 80 --expect \"Acme Inc\" tries: 5 try_sleep: 1s timeout: 10s ccm ensure service httpd running \\ --check '/usr/lib64/nagios/plugins/check_http -H localhost -p 80' \\ --check-tries 5 \\ --check-sleep 1s The CLI supports a single health check per resource. For multiple health checks, use a manifest.\nThis example verifies that the web server responds with content containing “Acme Inc”. If the check fails, it retries up to 5 times with 1 second between attempts.\nAgent Integration When running the Agent with health_check_interval configured, health checks run independently of full manifest applies. If any health check returns a CRITICAL status, the agent triggers a remediation apply for that manifest.",
    "description": "By default, CCM verifies resource health using the resource’s native state. For example, if a service should be running and systemd reports it as running, CCM considers it healthy.\nFor deeper validation, all resources support custom health checks. These checks run after a resource is managed and can verify that the resource is functioning correctly, not just present.\nHealth Check Properties Property Description Default command Command to execute (required) - name Name for logging and metrics Command base name tries Number of attempts before failing 1 try_sleep Duration to wait between retry attempts 1s timeout Maximum time for command execution No timeout format Output format interpretation nagios Nagios Format Health checks use Nagios plugin conventions for exit codes:",
    "tags": [],
    "title": "Monitoring",
    "uri": "/monitoring/index.html"
  },
  {
    "breadcrumb": "Introduction",
    "content": "Design documents provide detailed implementation guidance for CCM’s resource types, providers, and internal components. They are intended for developers contributing to CCM or those seeking to understand specific implementation details.\nFor end-user documentation on how to use resources, see Resources.\nNote These design documents are largely written with AI assistance and reviewed before publication.\nContents Each design document covers:\nPurpose and scope: What the component does and its responsibilities Architecture: How the component fits into CCM’s overall design Implementation details: Key data structures, interfaces, and algorithms Provider contracts: Requirements for implementing new providers Testing considerations: How to test the component Available Documents Document Description Archive Archive resource for downloading and extracting archives Exec Exec resource for command execution File File resource for managing files and directories Package Package resource for system package management Service Service resource for system service management",
    "description": "Design documents provide detailed implementation guidance for CCM’s resource types, providers, and internal components. They are intended for developers contributing to CCM or those seeking to understand specific implementation details.\nFor end-user documentation on how to use resources, see Resources.\nNote These design documents are largely written with AI assistance and reviewed before publication.\nContents Each design document covers:",
    "tags": [],
    "title": "Design Documents",
    "uri": "/design/index.html"
  },
  {
    "breadcrumb": "Introduction",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "Introduction",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
