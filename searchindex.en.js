var relearn_searchindex = [
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "A resource is how you describe the desired state of your infrastructure. They represent a thing you want to manage and they are backed by providers which implement the actual management for your Operating System.\nEach resource has a type and a unique name followed by some resource-specific properties.\nPackage When you manage a package, you describe the stable state you desire. Should the package merely be present, or the latest version, or a specific version?\nWarning You should use real package names, not virtual names, aliases or group names\nIn a manifest:\npackage: name: zsh ensure: 5.9 On the CLI:\n$ ccm ensure package zsh 5.9 Ensure Values Ensure Values present The package must be installed. latest The package must be installed and the latest version. absent The package must be not be installed. 5.9 The package must be installed and version 5.9. Properties Ensure Values name The resource name match the package name exactly ensure The desired state provider Force a specific provider to be used, only dnf supported Service When you manage a service, you describe the stable state you desire. Unlike packages services have 2 properties that can very - are they enabled to start at boot or should they be running.\nWarning You should use real service names, not virtual names, aliases etc\nAdditionally, a service can listen to the state changes of another resource, and, should that resource change it can force a restart of the service.\nIn a manifest:\nservice: name: httpd ensure: running enable: true subscribe: package#httpd On the CLI:\n$ ccm ensure service httpd running --enable --subscribe package#httpd Ensure Values Ensure Values running The service must be running. stopped The service must be stopped. Properties Ensure Values name The resource name match the service name exactly ensure The desired state enable (boolean) Enables the service to start at boot time subscribe When the service is set to be running, and it’s already running, restart it when th referenced resource changes provider Force a specific provider to be used, only systemd supported",
    "description": "A resource is how you describe the desired state of your infrastructure. They represent a thing you want to manage and they are backed by providers which implement the actual management for your Operating System.\nEach resource has a type and a unique name followed by some resource-specific properties.\nPackage When you manage a package, you describe the stable state you desire. Should the package merely be present, or the latest version, or a specific version?",
    "tags": [],
    "title": "Resources",
    "uri": "/resources/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "Just like applications need data to vary their behavior and configure their environments, so do Configuration Management tools.\nFor this reason I wrote extlookup and hiera years ago for the Puppet community. Despite the minimal focus of this tool we still need data to vary the behaviour.\nData can be used for:\nConfiguring resource names that differ between Operating Systems like httpd vs apache2 package names Set different configuration values depending on environment, role or other dimensions Decide if some environments shold have something installed and others not - like development vs production environments Choria CM supports various data sources:\nFacts about the instance - the Operating System, Networking and Disk configuration Environment data like variables read from the shell environment and files like ./.env Hiera Data data resolved using Hiera that supports hierarchical overrides based on facts Accessing Data In these examples you’ll see expressions like {{ lookup('facts.host.info.platformFamily') }}, these are written using Expr Language:\nExpr Language Expr Language Documentation We’ve added just the lookup(key, default) function to expr at this time, but it would be straightforward to add more as needs arise.\nThe lookup function takes a GJSON Path Syntax query and can dig into nested structures.\nThese expressions can be used in Hiera Data and even on the CLI.\n$ ccm ensure package '{{ lookup(\"data.package_name\", \"httpd\") }}' Above will fetch data from the runtime environment and default to httpd if not found.\nFacts We have a built-in fact resolver that gathers system information, we intend to expand this a bit, but today just the basic system facts are available.\nTo see the available facts, run:\n$ ccm facts $ ccm facts host $ ccm facts --yaml Accessing facts is via the expressions like {{ lookup('facts.host.info.platformFamily') }}.\nHiera Data for CLI Hiera Data is resolved using Choria Hierarchical Data Resolver and are ready by default from ./.hiera or a file you choose.\nNote This only works for ccm ensure, since apply is a Hiera manifest on it’s own it does not need this behavior\nGiven this example file stored in ./.hiera:\nhierarchy: order: - os:{{ lookup('facts.host.info.PlatformFamily') }} data: package_name: \"\" overrides: os:debian: package_name: apache2 os:rhel: package_name: httpd Running ccm ensure package '{{ lookup(\"data.package_name\") }}' will install httpd on RHEL based systems and apache2 on Debian based systems.\nEnvironment The shell environment and any environment data defined in ./.env can be accessed via expressions like {{ lookup(\"env.MY_VAR\") }}",
    "description": "Just like applications need data to vary their behavior and configure their environments, so do Configuration Management tools.\nFor this reason I wrote extlookup and hiera years ago for the Puppet community. Despite the minimal focus of this tool we still need data to vary the behaviour.\nData can be used for:\nConfiguring resource names that differ between Operating Systems like httpd vs apache2 package names Set different configuration values depending on environment, role or other dimensions Decide if some environments shold have something installed and others not - like development vs production environments Choria CM supports various data sources:",
    "tags": [],
    "title": "Data",
    "uri": "/data/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "We are designing CCM to be used as a CLI tool as its first class method of interaction.\nEach resource type has its own subcommand under ccm ensure that maps to the resource type, with required inputs being arguments and optionals being flags.\nThe CLI commands are designed to be idempotent; this means that they can be used to write shell scripts that can safely be run multiple times.\nManaging a single resource Managing a single resource is really easy, however, some features will not function without preparing a session.\n$ ccm ensure package zsh 5.8 Here we create a resource that ensures the package zsh is installed with version 5.8.\nManaging multiple resources When managing multiple resources, in a script it is worth creating a session and then running the commands. The purpose of the session is to record the outcome of earlier resource so that features like refreshing a Service when a File is updated will function correctly.\n#!/bin/bash eval $(ccm session new) ccm ensure package httpd ccm ensure file /etc/httpd/conf/httpd.conf .... ccm ensure service httpd --subscribe file#/etc/httpd/conf/httpd.conf ccm session report When this script is run it will create a temporary directory where session progress is stored, run the commands and should the file change the service will be restarted.\nIf evaluating random output from commands does not appeal then you can do this instead export CCM_SESSION_STORE=$(mktemp -d)\nData in the CLI As covered in the data section of the documentation the commands will read ./.env and ./.hiera files and merge that data into the session.\nThis behavior can be configured using the --hiera flag or CCM_HIERA_DATA environment variable to point to a specific file.\nWith this enabled you can access {{ lookup(\"data.my_data_key\") }} for Hiera data in your templates, {{ lookup(\"env.MY_ENV_VAR\") }} for environment variables and {{ lookup(\"facts.host.info.platformFamily\") }} for fact data.\nBelow we load the package name and version from Hiera and use them in a template to ensure the package is installed.\n$ ccm ensure package '{{ lookup(\"data.package\") }}' '{{ lookup(\"data.version\") }}' As pointed out these expressions are Expr Language so these expressions can be quite complex for example:\n$ ccm ensure package '{{ lookup(\"facts.host.info.platformFamily\") == \"rhel\" ? \"httpd\" : \"apache2\" }}' WARN package#httpd changed ensure=present runtime=14.509s provider=dnf Though of course we would recommend using Hiera data for this.",
    "description": "We are designing CCM to be used as a CLI tool as its first class method of interaction.\nEach resource type has its own subcommand under ccm ensure that maps to the resource type, with required inputs being arguments and optionals being flags.\nThe CLI commands are designed to be idempotent; this means that they can be used to write shell scripts that can safely be run multiple times.\nManaging a single resource Managing a single resource is really easy, however, some features will not function without preparing a session.",
    "tags": [],
    "title": "CLI Usage",
    "uri": "/cli/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "A manifest is a YAML file that combines data, platform-specific configuration and resources all in one file.\nThere is no logic - other than what expressions can do, consider it to be no more complex than basic example multi-resource shell scripts.\nThe YAML file resolves the manifest using Choria Hierarchical Data Resolver, our single-file implementation of Hiera.\nFull Example Input Data First, we define input data, think of this like the properties a module accepts:\ndata: package_name: \"httpd\" Resources We will manage the Apache Server package here:\nccm: resources: - package: name: \"{{ lookup('data.package_name') }}\" ensure: latest Configure Hierarchy We need to be able to configure the package name on a number of dimensions - like OS Platform - so we’ll create a Hierarchy here:\nhierarchy: order: - os:{{ lookup('facts.host.info.platformFamily') }} Here we will look for overrides in os:rhel, os:debian etc\nOverrides Finally, we configure a package name for Debian:\noverrides: os:debian: package_name: apache2 Applying the manifest Let’s apply the manifest, this is how it should look now:\ndata: package_name: \"httpd\" ccm: resources: - package: name: \"{{ lookup('data.package_name') }}\" ensure: latest hierarchy: order: - os:{{ lookup('facts.host.info.platformFamily') }} overrides: os:debian: package_name: apache2 We can apply this manifest like so, we can see first run makes a change 2nd run is stable:\n$ ccm apply manifest.yaml INFO Creating new session record resources=1 WARN package#httpd changed ensure=latest runtime=3.560699287s provider=dnf $ ccm apply manifest.yaml INFO Creating new session record resources=1 INFO package#httpd stable ensure=latest runtime=293.448824ms provider=dnf One can also see the fully resolved manifest and data without applying it:\n$ ccm apply manifest.yaml --render data: package_name: apache2 resources: - package: ensure: latest name: apache2",
    "description": "A manifest is a YAML file that combines data, platform-specific configuration and resources all in one file.\nThere is no logic - other than what expressions can do, consider it to be no more complex than basic example multi-resource shell scripts.\nThe YAML file resolves the manifest using Choria Hierarchical Data Resolver, our single-file implementation of Hiera.\nFull Example Input Data First, we define input data, think of this like the properties a module accepts:",
    "tags": [],
    "title": "YAML Manifests",
    "uri": "/yamlmanifests/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "Resources will check their health in the basic way that resources support - if you say a service should be running, if systemd says it’s running then we assume it’s healthy.\nIn some cases, though, it makes sense to go deeper than that, for example check the web server is actually serving correct content.\nAll resources support health checks.\nservice: name: httpd ensure: running enable: true subscribe: package#zsh health_check: tries: 5 try_sleep: 1s command: | /usr/lib64/nagios/plugins/check_http -H localhost:80 --expect \"Acme Inc\" Here we check that the web server is serving the correct content - the output must include Acme Inc. If at first it is not doing that we will try again every 1 second for five times.\nThese options are also available on the ccm ensure commands via the --check, --check-tries, --check-sleep flags.",
    "description": "Resources will check their health in the basic way that resources support - if you say a service should be running, if systemd says it’s running then we assume it’s healthy.\nIn some cases, though, it makes sense to go deeper than that, for example check the web server is actually serving correct content.\nAll resources support health checks.\nservice: name: httpd ensure: running enable: true subscribe: package#zsh health_check: tries: 5 try_sleep: 1s command: | /usr/lib64/nagios/plugins/check_http -H localhost:80 --expect \"Acme Inc\" Here we check that the web server is serving the correct content - the output must include Acme Inc. If at first it is not doing that we will try again every 1 second for five times.",
    "tags": [],
    "title": "Monitoring",
    "uri": "/monitoring/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
