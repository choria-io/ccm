var relearn_searchindex = [
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "A resource is how you describe the desired state of your infrastructure. They represent a thing you want to manage and they are backed by providers which implement the actual management for your Operating System.\nEach resource has a type and a unique name followed by some resource-specific properties.\nCommon Properties Resources can all have additional monitoring / health checks associated with them. See the Monitoring page for more information.\nAll resources can have an alias set which will be used in logging and to find resources for subscribe, require etc\nAll resources can have a require property that is a list of type#name or type#alias that must have succeeded before this resource can be applied.\nExec When you manage an exec resource, you describe a command that should be executed to bring the system into the desired state. The exec resource is idempotent when used with the creates property or refreshonly mode.\nWarning Commands should be specified with their full path, or use the path property to specify the search path\nIn a manifest:\nexec: name: /usr/bin/touch /tmp/hello ensure: present creates: /tmp/hello timeout: 30s cwd: /tmp require: - file#/usr/bin/touch On the CLI:\n$ ccm ensure exec \"/usr/bin/touch /tmp/hello\" --creates /tmp/hello --timeout 30s This will run the command only if /tmp/hello does not exist.\nEnsure Values The ensure property does not have meaning for the exec resource.\nProperties Property name The command to execute ensure The desired state cwd The working directory from which to run the command environment (array) Additional environment variables in KEY=VALUE format path The search path for executables, as a colon-separated list (e.g., /usr/bin:/bin) returns (array) Expected exit codes indicating success; defaults to 0 timeout Maximum time the command is allowed to run (e.g., 30s, 5m); command is killed if exceeded creates A file that the command creates; if this file exists the command will not run refreshonly (boolean) Only run the command when notified by a subscribed resource subscribe (array) Resources to subscribe to for refresh notifications in the format type#name or type#alias logoutput (boolean) Whether to log the command’s output provider Force a specific provider to be used, only posix supported File When managing a file you have to state the content, owner, group and mode the file should be.\nWarning You should use absolute file names and primary group names\nThe file type is very minimal at the moment, most important TODO items:\nSource file contents from elsewhere Support creating symlinks More complete templating for contents In a manifest:\nfile: name: /etc/motd ensure: present content: | Managed by CCM {{ now() }} owner: root group: root mode: \"0644\" On the CLI:\n$ ccm ensure file /etc/motd --source /tmp/ccm/motd --owner root --group root --mode 0644 This will copy the contents of /tmp/ccm/motd to /etc/motd verbatim and set the ownership.\nIf you specify --contents or --contents-file instead then the result will be parsed by a template and rendered as the contents.\nEnsure Values Ensure Values present The file must be nonexisting absent The file must exist directory The file must be a directory Properties Ensure Values name The resource name match the file name exactly ensure The desired state content The contents of the file, parsed through expr source Copy another file, in future will support remote sources owner The file owner group The file group mode The file mode, a string like 0700 provider Force a specific provider to be used, only postix supported Package When you manage a package, you describe the stable state you desire. Should the package merely be present, or the latest version, or a specific version?\nWarning You should use real package names, not virtual names, aliases or group names\nIn a manifest:\npackage: name: zsh ensure: 5.9 On the CLI:\n$ ccm ensure package zsh 5.9 Ensure Values Ensure Values present The package must be installed. latest The package must be installed and the latest version. absent The package must be not be installed. 5.9 The package must be installed and version 5.9. Properties Ensure Values name The resource name match the package name exactly ensure The desired state provider Force a specific provider to be used, only dnf supported Service When you manage a service, you describe the stable state you desire. Unlike packages services have 2 properties that can very - are they enabled to start at boot or should they be running.\nWarning You should use real service names, not virtual names, aliases etc\nAdditionally, a service can listen to the state changes of another resource, and, should that resource change it can force a restart of the service.\nIn a manifest:\nservice: name: httpd ensure: running enable: true subscribe: package#httpd On the CLI:\n$ ccm ensure service httpd running --enable --subscribe package#httpd Ensure Values Ensure Values running The service must be running. stopped The service must be stopped. Properties Ensure Values name The resource name match the service name exactly ensure The desired state enable (boolean) Enables the service to start at boot time subscribe (array) When the service is set to be running, and it’s already running, restart it when the referenced resource changes. In the format type#name or type#alias provider Force a specific provider to be used, only systemd supported",
    "description": "A resource is how you describe the desired state of your infrastructure. They represent a thing you want to manage and they are backed by providers which implement the actual management for your Operating System.\nEach resource has a type and a unique name followed by some resource-specific properties.\nCommon Properties Resources can all have additional monitoring / health checks associated with them. See the Monitoring page for more information.",
    "tags": [],
    "title": "Resources",
    "uri": "/resources/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "Choria Hierarchical Data Resolver is a small data resolver inspired by Hiera. It evaluates a YAML or JSON document alongside a set of facts to produce a final data map. The resolver supports first and deep merge strategies and relwies on simple string interpolation for hierarchy entries.\nIt is optimized for single files that hold the hierarchy and data rather than the multi-file approach common in Hiera.\nMajor features:\nLookup expressions based on a full language Types are supported, and lookups can return typed data Command line tool that includes built-in system facts Go library Usage Here’s an annotated example:\nhierarchy: # this is the lookup and override order, facts will be resolved here # # if your fact is nested, you can use gjson format queries like via the lookup function {{ lookup('networking.fqdn') }} order: - env:{{ lookup('facts.env') }} - role:{{ lookup('facts.role') }} - host:{{ lookup('facts.hostname') }} merge: deep # or first # This is the resulting output and must be present, the hierarchy results will be merged in data: log_level: INFO packages: - ca-certificates web: # we look up the number and convert its type to a int if the facts was not already an int listen_port: 80 tls: false overrides: env:prod: log_level: WARN role:web: packages: - nginx web: listen_port: 443 tls: true host:web01: log_level: TRACE The templating used here is identical to that used in the Data documentation section except that only the lookup() function was added not ones for accessing files etc.\nCLI Example A small utility is provided to resolve a hierarchy file and a set of facts. This utility has some different rules and behaviors for loading facts than the ccm suite in general since we want it to be a genericly usable tool even without system facts etc, so we make it easy to pass flags on the CLI etc.\nGiven the input file data.json:\n{ \"hierarchy\": { \"order\": [ \"fqdn:{{ lookup('facts.fqdn'}} }}\" ] }, \"data\": { \"test\": \"value\" }, \"overrides\": { \"fqdn:my.fqdn.com\": { \"test\": \"override\" } } } We can run the utility like this:\n$ ccm hiera parse data.json fqdn=my.fqdn.com { \"test\": \"override\" } $ ccm hiera parse data.json fqdn=other.fqdn.com { \"test\": \"value\" } It can also produce YAML output:\n$ ccm hiera parse test.json fqdn=other.fqdn.com --yaml test: value It can also produce Environment Variable output:\n$ ccm hiera parse test.json fqdn=other.fqdn.com --env HIERA_TEST=value In these examples we provided facts from a file or on the CLI, we can also populate the facts from an internal fact provider, first we view the internal facts:\n$ ccm hiera facts --system-facts { .... \"host\": { \"info\": { \"hostname\": \"example.net\", \"uptime\": 3725832, \"bootTime\": 1760351572, \"procs\": 625, \"os\": \"darwin\", \"platform\": \"darwin\", \"platformFamily\": \"Standalone Workstation\", \"platformVersion\": \"15.7.1\", \"kernelVersion\": \"24.6.0\", \"kernelArch\": \"arm64\", \"virtualizationSystem\": \"\", \"virtualizationRole\": \"\" } } .... Now we resolve the data using those facts:\n$ ccm hiera parse test.json --system-facts We can also populate the environment variables as facts, variables will be split on the = and the variable name becomes a fact name.\n$ ccm hiera parse test.json --env-facts These facts will be merged with ones from the command line and external files and all can be combined\nData in NATS NATS is a lightweight messaging system that is straightforward to run and host; it supports being used as a Key-Value store.\nWe can’t cover NATS here in detail here, but hierarchy data can be stored in NATS Key-Value stores and used in the ccm ensure and ccm hiera commands.\nTo use NATS as a hierarchy store, you need to configure a NATS context - a way to configure authentication or URLs for NATS.\nLet’s add a context called ccm for our needs:\n$ nats context add ccm --user nats.example.org --user ccm --password s£cret --description \"Choria CM Configuration Store\" We create a KV store that is stored replicated in a cluster and store the hierarchy from hiera.yaml in a Key called data:\n$ nats kv add CCM --replicas 3 --context ccm $ nats kv put CCM data \"$(cat hiera.yaml)\" We can now parse the hierarchy using system facts, this is identical to using the file locally:\n$ ccm hiera parse kv://CCM/data --context ccm -S Go example Supply a YAML document and a map of facts. The resolver will parse the hierarchy, replace {{ lookup('facts.fact') }} placeholders, and merge the matching sections.\nHere the hierarchy key defines the lookup strategies and the data key defines what will be returned.\nThe rest is the hierarchy data.\npackage main import ( \"fmt\" \"github.com/choria-io/ccm/hiera\" ) func main() { yamlDoc := []byte(` hierarchy: order: - env:{{ lookup('facts.env') }} - role:{{ lookup('facts.role') }} - host:{{ lookup('facts.hostname') }} merge: deep data: log_level: INFO packages: - ca-certificates web: listen_port: 80 tls: false overrides: env:prod: log_level: WARN role:web: packages: - nginx web: tls: true host:web01: log_level: TRACE `) facts := map[string]any{ \"env\": \"prod\", \"role\": \"web\", \"hostname\": \"web01\", } logger := manager.NewSlogLogger( slog.New( slog.NewTextHandler(os.Stderr, \u0026slog.HandlerOptions{Level: slog.LevelInfo}))) resolved, err := hiera.ResolveYaml(yamlDoc, facts, hiera.DefaultOptions, logger) if err != nil { panic(err) } jout, err := json.MarshalIndent(res, \"\", \" \") if err != nil { panic(err) } fmt.Println(string(jout)) }",
    "description": "Choria Hierarchical Data Resolver is a small data resolver inspired by Hiera. It evaluates a YAML or JSON document alongside a set of facts to produce a final data map. The resolver supports first and deep merge strategies and relwies on simple string interpolation for hierarchy entries.\nIt is optimized for single files that hold the hierarchy and data rather than the multi-file approach common in Hiera.\nMajor features:\nLookup expressions based on a full language Types are supported, and lookups can return typed data Command line tool that includes built-in system facts Go library Usage Here’s an annotated example:",
    "tags": [],
    "title": "Hierarchical Data",
    "uri": "/hiera/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "Just like applications need data to vary their behavior and configure their environments, so do Configuration Management tools.\nFor this reason I wrote extlookup and hiera years ago for the Puppet community. Despite the minimal focus of this tool we still need data to vary the behaviour.\nData can be used for:\nConfiguring resource names that differ between Operating Systems like httpd vs apache2 package names Set different configuration values depending on environment, role or other dimensions Decide if some environments shold have something installed and others not - like development vs production environments Choria CM supports various data sources:\nFacts about the instance - the Operating System, Networking and Disk configuration Environment data like variables read from the shell environment and files like ./.env Hiera Data data resolved using Hiera that supports hierarchical overrides based on facts Accessing Data In these examples you’ll see expressions like {{ lookup('facts.host.info.platformFamily') }}, these are written using Expr Language:\nExpr Language Expr Language Documentation We’ve added the following functions to Expr:\nFunction Description lookup(key, default) Lookup data from the runtime environment using GJSON Path Syntax readFile(file) Read a file into a string, can only read files in the working directory template(f) Parses f using templates jet(f), jet(f, \"[[\", \"]]\") Parses f using Jet templates, optionally specifying delimiters These expressions can be used in Hiera Data and even on the CLI.\n$ ccm ensure package '{{ lookup(\"data.package_name\", \"httpd\") }}' Above will fetch data from the runtime environment and default to httpd if not found.\nFacts We have a built-in fact resolver that gathers system information, we intend to expand this a bit, but today just the basic system facts are available.\nTo see the available facts, run:\n$ ccm facts $ ccm facts host $ ccm facts --yaml Accessing facts is via the expressions like {{ lookup('facts.host.info.platformFamily') }}.\nHiera Data for CLI Hiera Data is resolved using Choria Hierarchical Data Resolver and are ready by default from ./.hiera or a file you choose.\nNote This only works for ccm ensure, since apply is a Hiera manifest on it’s own it does not need this behavior\nGiven this example file stored in ./.hiera:\nhierarchy: order: - os:{{ lookup('facts.host.info.PlatformFamily') }} data: package_name: \"\" overrides: os:debian: package_name: apache2 os:rhel: package_name: httpd Running ccm ensure package '{{ lookup(\"data.package_name\") }}' will install httpd on RHEL based systems and apache2 on Debian based systems.\nNote See the Hiera section for details on how to configure Hiera Data in NATS\nThe data can also be stored in a NATS Key-Value store and read from there instead of from ./hiera by passing --context and --hiera kv://BUCKET/key options.\nEnvironment The shell environment and any environment data defined in ./.env can be accessed via expressions like {{ lookup(\"env.MY_VAR\") }}",
    "description": "Just like applications need data to vary their behavior and configure their environments, so do Configuration Management tools.\nFor this reason I wrote extlookup and hiera years ago for the Puppet community. Despite the minimal focus of this tool we still need data to vary the behaviour.\nData can be used for:\nConfiguring resource names that differ between Operating Systems like httpd vs apache2 package names Set different configuration values depending on environment, role or other dimensions Decide if some environments shold have something installed and others not - like development vs production environments Choria CM supports various data sources:",
    "tags": [],
    "title": "Data",
    "uri": "/data/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "We are designing CCM to be used as a CLI tool as its first class method of interaction.\nEach resource type has its own subcommand under ccm ensure that maps to the resource type, with required inputs being arguments and optionals being flags.\nThe CLI commands are designed to be idempotent; this means that they can be used to write shell scripts that can safely be run multiple times.\nManaging a single resource Managing a single resource is really easy, however, some features will not function without preparing a session.\n$ ccm ensure package zsh 5.8 Here we create a resource that ensures the package zsh is installed with version 5.8.\nWe can also get the current state of a resource using the status subcommand.\n$ ccm status package zsh Managing multiple resources When managing multiple resources, in a script it is worth creating a session and then running the commands. The purpose of the session is to record the outcome of earlier resource so that features like refreshing a Service when a File is updated will function correctly.\n#!/bin/bash eval $(ccm session new) ccm ensure package httpd ccm ensure file /etc/httpd/conf/httpd.conf .... ccm ensure service httpd --subscribe file#/etc/httpd/conf/httpd.conf ccm session report When this script is run it will create a temporary directory where session progress is stored, run the commands and should the file change the service will be restarted.\nIf evaluating random output from commands does not appeal then you can do this instead export CCM_SESSION_STORE=$(mktemp -d)\nData in the CLI As covered in the data section of the documentation the commands will read ./.env and ./.hiera files and merge that data into the session.\nThis behavior can be configured using the --hiera flag or CCM_HIERA_DATA environment variable to point to a specific file.\nWith this enabled you can access {{ lookup(\"data.my_data_key\") }} for Hiera data in your templates, {{ lookup(\"env.MY_ENV_VAR\") }} for environment variables and {{ lookup(\"facts.host.info.platformFamily\") }} for fact data.\nBelow we load the package name and version from Hiera and use them in a template to ensure the package is installed.\n$ ccm ensure package '{{ lookup(\"data.package\") }}' '{{ lookup(\"data.version\") }}' As pointed out these expressions are Expr Language so these expressions can be quite complex for example:\n$ ccm ensure package '{{ lookup(\"facts.host.info.platformFamily\") == \"rhel\" ? \"httpd\" : \"apache2\" }}' WARN package#httpd changed ensure=present runtime=14.509s provider=dnf Though of course we would recommend using Hiera data for this.",
    "description": "We are designing CCM to be used as a CLI tool as its first class method of interaction.\nEach resource type has its own subcommand under ccm ensure that maps to the resource type, with required inputs being arguments and optionals being flags.\nThe CLI commands are designed to be idempotent; this means that they can be used to write shell scripts that can safely be run multiple times.\nManaging a single resource Managing a single resource is really easy, however, some features will not function without preparing a session.",
    "tags": [],
    "title": "CLI Usage",
    "uri": "/cli/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "A manifest is a YAML file that combines data, platform-specific configuration and resources all in one file.\nThere is no logic - other than what expressions can do, consider it to be no more complex than basic example multi-resource shell scripts.\nThe YAML file resolves the manifest using Choria Hierarchical Data Resolver, our single-file implementation of Hiera.\nFull Example Input Data First, we define input data, think of this like the properties a module accepts:\ndata: package_name: \"httpd\" Resources We will manage the Apache Server package here:\nccm: resources: - package: - \"{{ lookup('data.package_name') }}\": ensure: latest Configure Hierarchy We need to be able to configure the package name on a number of dimensions - like OS Platform - so we’ll create a Hierarchy here:\nhierarchy: order: - os:{{ lookup('facts.host.info.platformFamily') }} Here we will look for overrides in os:rhel, os:debian etc\nOverrides Finally, we configure a package name for Debian:\noverrides: os:debian: package_name: apache2 Applying the manifest Let’s apply the manifest, this is how it should look now:\ndata: package_name: \"httpd\" ccm: resources: - package: - \"{{ lookup('data.package_name') }}\": ensure: latest hierarchy: order: - os:{{ lookup('facts.host.info.platformFamily') }} overrides: os:debian: package_name: apache2 We can apply this manifest like so, we can see first run makes a change 2nd run is stable:\n$ ccm apply manifest.yaml INFO Creating new session record resources=1 WARN package#httpd changed ensure=latest runtime=3.560699287s provider=dnf $ ccm apply manifest.yaml INFO Creating new session record resources=1 INFO package#httpd stable ensure=latest runtime=293.448824ms provider=dnf One can also see the fully resolved manifest and data without applying it:\n$ ccm apply manifest.yaml --render data: package_name: apache2 resources: - package: - apache2: ensure: latest Overriding Data It might be useful to override/augmenting the data in a manifest with another Hiera file, or KV bucket.\nTo do this pass --hiera kv://CCM/common to the ccm apply command.\nSetting Defaults Writing manifests with many similar resources can become tedious, we support setting defaults in the manifest itself:\nresources: - file: - defaults: owner: app group: app mode: \"0644\" ensure: present - /app/config/file.conf: source: file.conf - /app/bin/app: source: app.bin mode: \"0700\" - file: - /etc/motd: ensure: present source: motd.txt owner: root group: root mode: \"0644\" Here we create two files with the same owner and group but different contents and a different mode on one of the files. The motd file is unaffected by the defaults earlier as it’s a new scope.\nTemplating Manifests and resources support templates like {{ lookup(\"key\") }}, but these cannot be use to generate new resources, they are purely to adjust specific values in valid YAML files.\nMany times though one needs to create resources from data, for example you might have Hiera data that sets packages:\ndata: common_packages: - zsh - vim-enhanced - nagios-plugins-all - tar - nmap-ncat And want to set different packages for different nodes based on the Hierarchy, for this we can use Jet Templates\nFirst, we set the path to the template holding resources instead ot the resources themselves:\nccm: resources_jet_file: resources.jet {* resources.jet *} [[ range Data.common_packages ]] - package: - [[ . ]]: ensure: present [[ end ]] Note The template should be in the same directory as the manifest\nThe data available in this template will be post Hierarchy evaluation so you will have access to the full Hierarchy resolved data, additionally you can also access Facts and Environ.\nControlling failure handling By default, if any resource fails, the apply will continue to the next resource, and at the moment we do not have any concept that let one resource require another.\nThis behavior can be controlled by using the fail_on_error flag which will terminate the manifest apply as soon as a resource fails.\nccm: fail_on_error: true resources: - exec: - /usr/bin/false: {} - /usr/bin/true: {} When running we can see the second is never invoked:\n$ ccm apply manifest.yaml INFO Executing manifest manifest=manifest.yaml resources=2 ERROR exec#/usr/bin/false failed ensure=present runtime=3ms provider=posix errors=failed to reach desired state exit code 1 WARN Terminating manifest execution due to failed resource Checking what would be done (Noop mode) One can ask the system to operate in Noop mode, meaning it will attempt to detect what would happen without actually doing it.\nThis is achieved by using the --noop flag.\nNote Noop mode is not perfect, if a change in a resource affects a future resource, it cannot always be detected.\nManifests in NATS Object Store Like Hierarchical Data data can be accessed via NATS Server to avoid needing all the manifests and hiera files locally.\nNATS is a lightweight messaging system that is straightforward to run and host; it supports being used as a Key-Value store.\nWe can’t cover NATS here in detail here, but manifest and dependant files can be stored in NATS Object Stores and used in the ccm apply command.\nLet’s add a context called ccm for our needs:\n$ nats context add ccm --user nats.example.org --user ccm --password s£cret --description \"Choria CM Configuration Store\" We create a Object Store stored replicated in a cluster and store the hierarchy from hiera.yaml in a Key called data:\n$ nats obj add CCM --replicas 3 --context ccm Let’s create a manifest that copies a file onto the node:\n$ mkdir /tmp/manifest $ echo 'CCM Managed' \u003e /tmp/manifest/mode $ vi /tmp/manifest/manifest.yaml ... ccm: resources: - file: - /etc/motd: ensure: present source: motd owner: root group: root mode: \"0644\" You can see here we read the file motd and copy it to /etc/motd on the node.\nLet’s create a tar file and place it in the Object Store:\n$ tar -C /tmp/manifest/ -cvzf /tmp/manifest.tgz . $ cd /tmp $ nats --server localhost:4222 obj put CCM manifest.tgz We can now apply the manifest:\n$ ccm apply obj://CCM/manifest.tgz --context local INFO Using manifest from Object Store in temporary directory bucket=CCM file=manifest.tgz INFO file#/etc/motd stable ensure=present runtime=0s provider=posix",
    "description": "A manifest is a YAML file that combines data, platform-specific configuration and resources all in one file.\nThere is no logic - other than what expressions can do, consider it to be no more complex than basic example multi-resource shell scripts.\nThe YAML file resolves the manifest using Choria Hierarchical Data Resolver, our single-file implementation of Hiera.\nFull Example Input Data First, we define input data, think of this like the properties a module accepts:",
    "tags": [],
    "title": "YAML Manifests",
    "uri": "/yamlmanifests/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "Resources will check their health in the basic way that resources support - if you say a service should be running, if systemd says it’s running then we assume it’s healthy.\nIn some cases, though, it makes sense to go deeper than that, for example, check the web server is actually serving correct content.\nAll resources support health checks.\nservice: name: httpd ensure: running enable: true subscribe: package#zsh health_checks: - tries: 5 try_sleep: 1s name: check_http command: | /usr/lib64/nagios/plugins/check_http -H localhost:80 --expect \"Acme Inc\" Here we check that the web server is serving the correct content - the output must include Acme Inc. If at first it is not doing that we will try again every 1 second for five times.\nWhen name is not set it will be set to base name of the command, this name will show up in logs etc.\nThese options are also available on the ccm ensure commands via the --check, --check-tries, --check-sleep flags. While resources support multiple health checks the CLI ensure command supports adding only one.",
    "description": "Resources will check their health in the basic way that resources support - if you say a service should be running, if systemd says it’s running then we assume it’s healthy.\nIn some cases, though, it makes sense to go deeper than that, for example, check the web server is actually serving correct content.\nAll resources support health checks.\nservice: name: httpd ensure: running enable: true subscribe: package#zsh health_checks: - tries: 5 try_sleep: 1s name: check_http command: | /usr/lib64/nagios/plugins/check_http -H localhost:80 --expect \"Acme Inc\" Here we check that the web server is serving the correct content - the output must include Acme Inc. If at first it is not doing that we will try again every 1 second for five times.",
    "tags": [],
    "title": "Monitoring",
    "uri": "/monitoring/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "Choria Configuration Manager",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
